const PreceptPointEditMode = {
    SelectValuePopup: "SelectValuePopup",
    EditInplaceContent: "EditInplaceContent"
};

class PreceptPointParams {}

class QuestionData {
    constructor(questionId, questionNumber) {
        this.questionId = questionId;
        this.questionNumber = questionNumber;
    }
}

class QuestionPreceptData {
    constructor(questionNumber, questionId, pointsText) {
        this.questionNumber = questionNumber;
        this.questionId = questionId;
        this.pointsText = pointsText;
    }
}

class QuestionPreceptOption {}

class PreceptPointsController {
    constructor(questionDataGetter, preceptPointGetter) {
        this.questionDataGetter = questionDataGetter;
        this.preceptPointGetter = preceptPointGetter;
        this.isOldShit = isOldSafari() | !CSS.supports(`selector(:has(*))`);
    }
    setOnChangedCallback(onChangedCallback) {
        this.onChangedCallback = onChangedCallback;
    }
    onChanged() {
        if (this.onChangedCallback) {
            this.onChangedCallback.call(undefined);
        }
    }
    buildUI($items) {
        for (const element of $items) {
            let [questionData, pointData] = this.getElementData(element);
            if (questionData && pointData) {
                this.buildElementUI(element, questionData, pointData);
            }
        }
    }
    buildElementUI(element, questionData, pointData) {
        if (pointData) {
            let $el = $(element);
            if (pointData.showInstructions) {
                this.buildInstructions($el, pointData);
            }
        }
    }
    buildInstructions($items, pointData) {}
    generateSubmitData() {
        let result = new PreceptPointsUserAnswer;
        let items = $(".question-message");
        for (const node of items) {
            let [question, pointData] = this.getElementData(node);
            if (question) {
                let questionAnswer = this.doBuildQuestionPointsAnswer($(node), question.questionNumber, question.questionId);
                if (questionAnswer) {
                    result.data.push(questionAnswer);
                }
            }
        }
        return result.data.length > 0 ? result : undefined;
    }
    getElementData(element) {
        let questionData = this.questionDataGetter.call(this, element);
        if (!questionData) return [ undefined, undefined ];
        let pointData = this.preceptPointGetter.call(this, questionData);
        return [ questionData, pointData ];
    }
    getElementsMessages(elements) {
        let $el = $(elements);
        return $el.hasClass("question-message") ? $el : $el.find(".question-message");
    }
    buildQuestionPointsAnswer(element) {
        const $el = element instanceof jQuery ? element : $(element);
        let number = Number.parseInt($el.data("question-number"));
        let id = $el.find(".freebirdFormviewerComponentsQuestionBaseRoot").data(".question-id");
        return this.doBuildQuestionPointsAnswer($el, number, id);
    }
    doBuildQuestionPointsAnswer($el, questionNumber, questionId) {
        return undefined;
    }
    getWordPointElementUserAnswer(wordNode) {}
    buildQuestionExtra(questionElement) {
        let $item = this.getElementsMessages(questionElement);
        let [question, pointData] = this.getElementData($item[0]);
        if (pointData && pointData.messageUnderlines) {
            let html = $item.html();
            return html ? this.prepareExtraHtml(html, pointData) : html;
        }
    }
    buildExtras() {
        let $items = $(".question-message");
        for (const node of $items) {
            let [question, pointData] = this.getElementData(node);
            if (!question || !pointData) continue;
            if (pointData.messageUnderlines) {
                const $node = $(node);
                let html = $node.html();
                if (html) {
                    html = this.prepareExtraHtml(html, pointData);
                    const $cont = $node.closest(".question-message-wrapper");
                    const id = `question-textarea${question.questionNumber}`;
                    const $existing = $cont.find("#" + id);
                    if ($existing.length > 0) {
                        $existing.val(html);
                    } else {
                        $cont.append(`<textarea id="${id}" name="questionExtra${question.questionNumber}" class="hidden">${html}</textarea>`);
                    }
                }
            }
        }
    }
    prepareExtraHtml(html, pointData) {
        return undefined;
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {}
    saveInitialEditableHtml($el, tag) {
        if (!this.savedHtml) {
            this.savedHtml = {};
        }
        this.savedHtml[tag] = $el.html();
    }
}

class AllPreceptPointsControllers extends PreceptPointsController {
    constructor(questionDataGetter, preceptPointGetter) {
        super(questionDataGetter, preceptPointGetter);
        this.controllers = new Map;
    }
    buildElementUI(element, questionData, pointData) {
        if (pointData) {
            this.getController(pointData.behavior).buildElementUI(element, questionData, pointData);
        }
    }
    generateSubmitData() {
        let result = new PreceptPointsUserAnswer;
        let items = $(".question-message");
        for (const node of items) {
            let [question, pointData] = this.getElementData(node);
            if (question && pointData) {
                let questionAnswer = this.getController(pointData.behavior).doBuildQuestionPointsAnswer($(node), question.questionNumber, question.questionId);
                if (questionAnswer) {
                    result.data.push(questionAnswer);
                }
            }
        }
        return result.data.length > 0 ? result : undefined;
    }
    prepareExtraHtml(html, pointData) {
        return this.getController(pointData.behavior).prepareExtraHtml(html, pointData);
    }
    buildQuestionPointsAnswer(element) {
        const $el = element instanceof jQuery ? element : $(element);
        let $item = this.getElementsMessages($el);
        let [question, pointData] = this.getElementData($item);
        return pointData && question ? this.getController(pointData.behavior).doBuildQuestionPointsAnswer($item, question.questionNumber, question.questionId) : undefined;
    }
    buildQuestionExtra(questionElement) {
        let $item = this.getElementsMessages(questionElement);
        let [question, pointData] = this.getElementData($item[0]);
        return pointData ? this.getController(pointData.behavior).buildQuestionExtra(questionElement) : undefined;
    }
    getController(behavior) {
        let controller = this.controllers.get(behavior);
        if (controller) return controller;
        controller = this.createController(behavior);
        controller.setOnChangedCallback(this.onChangedCallback);
        this.controllers.set(behavior, controller);
        return controller;
    }
    setOnChangedCallback(callback) {
        super.setOnChangedCallback(callback);
        for (let controller of this.controllers.values()) {
            controller.setOnChangedCallback(callback);
        }
    }
    createController(behavior) {
        switch (behavior) {
          case PreceptPointBehavior.Letters:
          case PreceptPointBehavior.LettersInText:
          case PreceptPointBehavior.MultiTypePointsInText:
            return new LettersPreceptController(this.questionDataGetter, this.preceptPointGetter);

          case PreceptPointBehavior.TogetherSeparately:
            return new TogetherSeparatelyController(this.questionDataGetter, this.preceptPointGetter);

          case PreceptPointBehavior.Commas:
            return new CommasPointsController(this.questionDataGetter, this.preceptPointGetter);

          case PreceptPointBehavior.LettersWithKeyNumbers:
            return new LettersWithKeyNumbersPointsController(this.questionDataGetter, this.preceptPointGetter);

          case PreceptPointBehavior.MultiSelectPrecept:
            return new MultiSelectPreceptsController(this.questionDataGetter, this.preceptPointGetter);

          case PreceptPointBehavior.CommasWithKeyNumbers:
            return new CommasWithKeysPointsController(this.questionDataGetter, this.preceptPointGetter);

          case PreceptPointBehavior.ReplaceWordInMarkup:
            return new MarkdownHintsController(this.questionDataGetter, this.preceptPointGetter);

          default:
            return new PreceptPointsController(this.questionDataGetter, this.preceptPointGetter);
        }
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {
        let $item = this.getElementsMessages($el[0]);
        let [question, pointData] = this.getElementData($item[0]);
        if (pointData) {
            this.getController(pointData.behavior).fillQuestionExtrasAndPreceptPoints($el, questionData, type);
        }
    }
}

class MultiSelectPreceptsController extends PreceptPointsController {
    buildElementUI(element, questionData, pointData) {
        if (!pointData) return;
        const $el = $(element);
        this.saveInitialEditableHtml($el, "message");
        $el.wrap("<div class='question-message-wrapper'></div>");
        const $cont = $el.parent();
        if (pointData.messageUnderlines) {
            $el.trumbowyg(TW_EDIT_PROPS).on("tbwchange", this.onChanged.bind(this));
        }
        if (!pointData.pointsText || pointData.pointsText.length === 0 || !pointData.selectOptions || pointData.selectOptions.length === 0) {
            return;
        }
        $cont.append("<div class='multi-select-precepts-cont printer-hidden'></div>");
        const $preceptsCont = $cont.find(".multi-select-precepts-cont");
        if (pointData.optionsTitle) {
            $preceptsCont.append(`<div class='multi-select-precepts-title'>${pointData.optionsTitle}</div>`);
        }
        const $select = this.buildSelect(pointData);
        for (const sentenceN of pointData.pointsText.split(",")) {
            $preceptsCont.append(this.buildSentence(sentenceN, pointData, $select.clone()));
        }
    }
    buildSelect(pointData) {
        const $select = $(`<select class="precepts-multi-select" multiple="multiple"></select>`);
        $select.append("<option value='0'>Нет</option>");
        for (const option of pointData.selectOptions) {
            $select.append(`<option value='${option.number}'>${option.title}</option>`);
        }
        return $select;
    }
    buildSentence(sentenceN, pointData, $select) {
        const id = `precept-select-${pointData.questionNumber}-${sentenceN}`;
        $select.attr("id", id);
        $select.attr("name", id);
        const $lineCont = $(`<div class='multiselect-precept-line'><label for'${id}'>Предложение ${sentenceN}:</label></div>`);
        $lineCont.append($select);
        $select.wrap("<div class='multiselect-precept-select-cont'></div>");
        $select.select2().on("select2:select", this.onOptionSelected.bind(this));
        return $lineCont;
    }
    onOptionSelected(e) {
        const data = e.params.data;
        if (data.selected) {
            const $select = $(e.target);
            let $unselect;
            if (data.id === "0") {
                $unselect = $select.find("option:checked:not([value=0])");
            } else {
                $unselect = $select.find("option:checked[value=0]");
            }
            if ($unselect.length > 0) {
                $unselect.prop("selected", false);
                $select.trigger("change");
            }
            this.onChanged();
        }
    }
    doBuildQuestionPointsAnswer($el, questionNumber, questionId) {
        let result = new PreceptPointsQuestionAnswer(questionId, questionNumber);
        let $items = $el.hasClass("question-message") ? $el : $el.find(".question-message");
        for (const node of $items) {
            const $wrapper = $(node).closest(".question-message-wrapper");
            for (const selectEl of $wrapper.find(".multiselect-precept-line select.precepts-multi-select")) {
                const $select = $(selectEl);
                const id = $select.attr("id");
                const sentenceNumberStr = id.split("-").pop();
                let idx = Number.parseInt(sentenceNumberStr);
                for (const optionEl of $select.find("option:checked")) {
                    result.items.push(new PreceptPointAnswer(idx, sentenceNumberStr, $(optionEl).val()));
                }
            }
        }
        return result;
    }
    prepareExtraHtml(html) {
        return html;
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {
        if (questionData.extraAnswer) {
            let $message = $el.find(".question-message");
            $message.html(questionData.extraAnswer);
        }
        for (let item of questionData.pointAnswer.items) {
            let $select = $(`select#precept-select-${questionData.number}-${item.i}`);
            let $option = $select.find(`option[value=${item.a}]`);
            $option.attr("selected", true);
            $select.trigger("change");
        }
    }
}

class CommasPointsController extends PreceptPointsController {
    buildElementUI(element, questionData, pointData) {
        if (!pointData) return;
        super.buildElementUI(element, questionData, pointData);
        let $el = $(element);
        if (pointData.messageUnderlines) {
            this.saveInitialEditableHtml($el, "message");
            $el.wrap("<div class='question-message-wrapper'></div>");
            $el.trumbowyg(TW_EDIT_PROPS).on("tbwchange", this.onTrumbowygChanged.bind(this));
        }
        this.createUIElements($el, questionData, false);
    }
    createUIElements($el, questionData, fillCommas) {
        let htmlIterator = new HtmlIterator($el[0]);
        let pattern = fillCommas ? /([а-яёa-z“”"'«»‟„‚‘’()-]+)((?:,\u200b)*[^\S\r\n]|$)/gimu : /([а-яёa-z“”"'«»‟„‚‘’()-]+)([^\S\r\n]|$)/gimu;
        let words = htmlIterator.findWordsByRegEx(pattern, 1, 2);
        for (let i = words.length - 1; i >= 0; --i) {
            let word = words[i];
            this.buildWordUi(htmlIterator, word, questionData, i);
        }
        $el.find("br").before("\n");
        $el.find("p").append("\n");
        $el.find(".commaWordSpacePoint").each((function(idx) {
            let el = $(this);
            if (el.text() === "") el.text(" ");
        }));
        $el.find(".commaWordPoint").after("​");
        this.registerClicks($el);
    }
    buildInstructions($items) {
        $items.before("<p class='precept-instructions'>Расставь запятые (нажатием на слово или пробел между словами). Ты можешь подчёркивать слова. Предложения без знаков препинания, которые нужны, будут считаться предложениями с ошибками.</p>");
    }
    registerClicks($elements) {
        let that = this;
        MOUSE_CLICK_HELPER.addClickListener($elements.find(".commaWordSpacePoint"), (function(e) {
            that.onSpaceClick(e, this);
        }));
        MOUSE_CLICK_HELPER.addClickListener($elements.find(".commaWordPoint"), this.onWordClick);
    }
    onTrumbowygChanged(e) {
        this.registerClicks($(e.target));
        this.onChanged();
    }
    buildWordUi(htmlIterator, word, questionData, idx) {
        let element = htmlIterator.wrapSelectedText(word.start, word.end, "span", "commaWordPoint");
        let el = $(element);
        el.data("questionId", questionData.questionId);
        el.data("questionNumber", questionData.questionNumber);
        el.data("idx", idx);
        el.data("word", word.word);
        try {
            let spaceElement = htmlIterator.wrapSelectedText(word.tokenStart, word.tokenEnd, "span", "commaWordSpacePoint");
            let tokenText = spaceElement.textContent;
            if (tokenText[0] === ",") {
                $(spaceElement).html("<span class='comma'>,</span><span> </span>");
            }
        } catch (e) {
            console.error(JSON.stringify(word));
            console.error(JSON.stringify(questionData));
            console.error(e);
        }
    }
    onSpaceClick(e, thisElement) {
        e.stopPropagation();
        let el = $(thisElement);
        el.html(el.text().indexOf(",") < 0 ? "<span class='comma'>,</span><span> </span>" : " ");
        this.onChanged();
    }
    onWordClick(e) {
        e.stopPropagation();
        $(this).find(".commaWordSpacePoint").click();
    }
    doBuildQuestionPointsAnswer($el, questionNumber, questionId) {
        let result = new PreceptPointsQuestionAnswer(questionId, questionNumber);
        let $items = this.getElementsMessages($el);
        for (const node of $items) {
            let text = $(node).text().trim().replaceAll(/[^\S\r\n]+/g, " ");
            result.items.push(new PreceptPointAnswer(0, "", text));
        }
        return result;
    }
    prepareExtraHtml(html) {
        html = html.replaceAll(/\s+/g, " ").replaceAll("​", "");
        let $cont = $("<div></div>");
        $cont.append(html);
        $cont.find(".comma").text(",​");
        $cont.find("span.commaWordSpacePoint").replaceWith((function() {
            return $(this).text();
        }));
        $cont.find("span.commaWordPoint").replaceWith((function() {
            return this.innerHTML;
        }));
        let underlineTags = [ "du", "wu", "u", "dtu", "dau", "ddu" ];
        html = $cont.html();
        html = html.replaceAll(/<\/(\w+)><\1>/g, ((match, group1) => underlineTags.indexOf(group1.toLowerCase()) >= 0 ? "" : match));
        return html;
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {
        if (questionData.extraAnswer) {
            let $message = $el.find(".question-message");
            $message.html(questionData.extraAnswer);
            let qd = {
                questionNumber: questionData.number,
                questionId: questionData.questionId
            };
            this.createUIElements($message, qd, true);
        }
    }
}

class CommasWithKeysPointsController extends CommasPointsController {
    buildInstructions($items) {
        $items.before("<p class='precept-instructions'>Ты можешь расставлять запятые (нажатием на слово или пробел между словами) и подчёркивать слова.</p>");
    }
}

class PreceptPointsWordController extends PreceptPointsController {
    parseWords(htmlIterator) {
        return [];
    }
    parsePointWords(pointData) {
        return [];
    }
    buildWordUi(htmlIterator, word, questionData, idx) {}
    buildElementUI(element, questionData, pointData) {
        if (!pointData) return;
        super.buildElementUI(element, questionData, pointData);
        let htmlIterator = new HtmlIterator(element);
        let words = this.parseWords(htmlIterator);
        if (words.length === 0) return;
        for (let word of words) {
            word.word = word.word.replaceAll("­", "");
        }
        let pointWords = this.parsePointWords(pointData);
        for (let i in pointWords) {
            pointWords[i] = pointWords[i].replaceAll("­", "");
        }
        for (let i = words.length - 1; i >= 0; --i) {
            let word = words[i];
            let idx = pointWords.lastIndexOf(word.word);
            if (idx >= 0) {
                this.buildWordUi(htmlIterator, word, questionData, idx);
                pointWords[idx] = Number.NaN;
            }
        }
    }
    getWordPointSelector() {}
    doBuildQuestionPointsAnswer($el, questionNumber, questionId) {
        let result = new PreceptPointsQuestionAnswer(questionId, questionNumber);
        let items = $el.find(this.getWordPointSelector());
        for (const node of items) {
            let $el = $(node);
            let itemData = $el.data();
            let answer = this.getWordPointElementUserAnswer($el);
            result.items.push(new PreceptPointAnswer(itemData.idx, itemData.word, answer));
        }
        return result;
    }
}

const JoinedSeparatedSelection = Object.freeze({
    Unselected: "Unselected",
    Joined: "Joined",
    Separated: "Separated",
    Dashed: "Dashed"
});

class TogetherSeparatelyController extends PreceptPointsWordController {
    parseWords(htmlIterator) {
        return htmlIterator.findWordsByRegEx(/(([А-ЯЁ]+|\([А-ЯЁ]+\)){2,})/g, 1, 1);
    }
    parsePointWords(pointData) {
        let pointWords = [];
        for (const match of pointData.pointsText.matchAll(/([А-ЯЁ()]*)\{\}([А-ЯЁ()]+)/g)) {
            pointWords.push(match[0].replaceAll("{}", ""));
        }
        return pointWords;
    }
    buildWordUi(htmlIterator, word, questionData, idx) {
        let partMatches = Array.from(word.word.matchAll(/([А-ЯЁ]+|\([А-ЯЁ]+\))/g));
        let cls = partMatches.length > 2 ? "selectPointTogetherSeparated Multiple" : "selectPointTogetherSeparated";
        cls += " preceptPointWord";
        let element = htmlIterator.wrapSelectedText(word.start, word.end, "span", cls);
        let el = $(element);
        el.data("questionId", questionData.questionId);
        el.data("questionNumber", questionData.questionNumber);
        el.data("idx", idx);
        el.data("word", word.word);
        for (let i = 1; i < partMatches.length; i++) {
            const match = partMatches[i];
            let pos = word.start + match.index;
            htmlIterator.wrapSelectedText(pos, pos, "b", "wordSeparator");
        }
        for (const match of word.word.matchAll(/[()]/g)) {
            let pos = word.start + match.index;
            htmlIterator.wrapSelectedText(pos, pos + 1, "span", "wordPar");
        }
    }
    buildElementUI(element, questionData, pointData) {
        super.buildElementUI(element, questionData, pointData);
        this.enableToggle($(element));
    }
    enableToggle($elements) {
        let that = this;
        $elements.find(".selectPointTogetherSeparated:not(.Multiple)").click((function(e) {
            e.stopPropagation();
            that.toggleElementState($(this).find(".wordSeparator"));
        }));
        $elements.find(".selectPointTogetherSeparated .wordSeparator").click((function(e) {
            e.stopPropagation();
            that.toggleElementState($(this));
        }));
    }
    toggleElementState(element) {
        let state = this.getSeparatorState(element);
        switch (state) {
          case JoinedSeparatedSelection.Joined:
            this.setElementState(element, JoinedSeparatedSelection.Separated);
            break;

          case JoinedSeparatedSelection.Separated:
            let [questionData, pointData] = this.getElementData(element);
            if (pointData.options.indexOf("-") >= 0) {
                this.setElementState(element, JoinedSeparatedSelection.Dashed);
            } else {
                this.setElementState(element, JoinedSeparatedSelection.Unselected);
            }
            break;

          case JoinedSeparatedSelection.Dashed:
            this.setElementState(element, JoinedSeparatedSelection.Unselected);
            break;

          case JoinedSeparatedSelection.Unselected:
            this.setElementState(element, JoinedSeparatedSelection.Joined);
            break;
        }
        this.onChanged();
    }
    setElementState(element, mode) {
        element.removeClass(JoinedSeparatedSelection.Joined);
        element.removeClass(JoinedSeparatedSelection.Separated);
        element.removeClass(JoinedSeparatedSelection.Dashed);
        element.removeClass("required");
        element.removeClass("hasUserSelection");
        switch (mode) {
          case JoinedSeparatedSelection.Joined:
          case JoinedSeparatedSelection.Separated:
          case JoinedSeparatedSelection.Dashed:
            element.addClass(mode);
            element.addClass("hasUserSelection");
            break;
        }
        if (this.isOldShit) {
            let $word = element.closest(".preceptPointWord");
            $word.find(".wordPar").removeClass("hidden");
            if ($word.find(".wordSeparator:not(.hasUserSelection)").length === 0) {
                $word.find(".wordPar").addClass("hidden");
            } else {
                $word.find(".wordSeparator.hasUserSelection + .wordPar, .wordPar:has( + .wordSeparator.hasUserSelection)").addClass("hidden");
            }
        }
    }
    getSeparatorState(element) {
        if (element.hasClass(JoinedSeparatedSelection.Joined)) return JoinedSeparatedSelection.Joined;
        if (element.hasClass(JoinedSeparatedSelection.Separated)) return JoinedSeparatedSelection.Separated;
        if (element.hasClass(JoinedSeparatedSelection.Dashed)) return JoinedSeparatedSelection.Dashed;
        return JoinedSeparatedSelection.Unselected;
    }
    getWordPointSelector() {
        return ".selectPointTogetherSeparated";
    }
    getWordPointElementUserAnswer($el) {
        let answer = "";
        for (const wordSeparator of $el.find(".wordSeparator")) {
            let state = this.getSeparatorState($(wordSeparator));
            answer += this.getStateOutput(state);
        }
        return answer;
    }
    getStateOutput(state) {
        if (!state) {
            return JoinedSeparatedSelection.Unselected;
        }
        switch (state) {
          case JoinedSeparatedSelection.Joined:
            return "j";

          case JoinedSeparatedSelection.Separated:
            return "s";

          case JoinedSeparatedSelection.Dashed:
            return "-";

          case ".":
            return JoinedSeparatedSelection.Unselected;
        }
    }
    getStateOfOutput(stateChar) {
        switch (stateChar.toLowerCase()) {
          case "j":
            return JoinedSeparatedSelection.Joined;

          case "s":
            return JoinedSeparatedSelection.Separated;

          case "-":
            return JoinedSeparatedSelection.Dashed;

          default:
            return JoinedSeparatedSelection.Unselected;
        }
    }
    buildInstructions($items, pointData) {
        if (pointData.egeNumber === 14) {
            $items.before(`<p class='precept-instructions'>Ты можешь выбирать слитное, раздельное или дефисное написание, нажимая на слово несколько раз.<br/> \nСлова, в которых ты не выберешь написание, будут считаться словами с ошибкой.</p>`);
        } else {
            $items.before(`<p class='precept-instructions'>Ты можешь выбирать слитное или раздельное написание, нажимая на слово несколько раз.<br/>\n Слова, в которых ты не выберешь написание, будут считаться словами с ошибкой.</p>`);
        }
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {
        if (questionData.pointAnswer && questionData.pointAnswer.items) {
            let $wordElements = $el.find(".selectPointTogetherSeparated");
            for (let i = 0; i < $wordElements.length; i++) {
                let $wordEl = $($wordElements[i]);
                let data = questionData.pointAnswer.items[i];
                if (!data || !data.a || data.a === ".") {
                    continue;
                }
                let $separators = $wordEl.find(".wordSeparator");
                for (let j = 0; j < $separators.length; j++) {
                    let $sep = $($separators[j]);
                    let stateChar = data.a[j];
                    let state = this.getStateOfOutput(stateChar);
                    this.setElementState($sep, state);
                }
            }
        }
    }
}

class LettersPreceptController extends PreceptPointsWordController {
    constructor(questionDataGetter, preceptPointGetter) {
        super(questionDataGetter, preceptPointGetter);
        this.mode = PreceptPointEditMode.EditInplaceContent;
    }
    parseWords(htmlIterator) {
        return htmlIterator.findWords("..");
    }
    parsePointWords(pointData) {
        let pointWords = [];
        for (const match of pointData.pointsText.matchAll(/([а-яё\xAD\u0301]*(\{\})+[а-яё\xAD\u0301]*)+/giu)) {
            pointWords.push(match[0].replaceAll("{}", ".."));
        }
        return pointWords;
    }
    buildWordUi(htmlIterator, word, questionData, idx) {
        htmlIterator.wrapSelectedText(word.start, word.end, "span", "selectPointLetterWord preceptPointWord");
        let element = htmlIterator.wrapSelectedText(word.tokenStart, word.tokenEnd + 1, "span", "selectPointLetter ");
        let el = $(element);
        el.data("questionId", questionData.questionId);
        el.data("questionNumber", questionData.questionNumber);
        el.data("idx", idx);
        el.data("word", word.word);
        if (this.mode === PreceptPointEditMode.EditInplaceContent) {
            el.addClass("editable");
            el.attr("contenteditable", true);
            el.empty();
        }
    }
    buildElementUI(element, questionData, pointData) {
        super.buildElementUI(element, questionData, pointData);
        let $element = $(element);
        this.fillSelectionPopUp($element, pointData);
        this.addClickHandlers($element);
    }
    fillSelectionPopUp($elements, pointData) {
        let cont = $("#customCombobox");
        cont.empty();
        cont.append("<div data-value='unset'>..</div>");
        pointData.options.sort();
        for (let option of pointData.options) {
            if (option === "") {
                cont.append(`<div data-value='' class="span2">пусто</div>`);
            } else {
                cont.append(`<div data-value='${option}'>${option}</div>`);
            }
        }
        if (pointData.options.length > 3) {
            cont.addClass("grid-layout");
        }
        $elements.find("#customCombobox div").on("click", (function() {
            let selectedValue = $(this).data("value");
            if (LettersPreceptController.$currentElement) {
                if (selectedValue === "unset") {
                    LettersPreceptController.$currentElement.removeClass("userFilled");
                    LettersPreceptController.$currentElement.text("..");
                } else {
                    LettersPreceptController.$currentElement.addClass("userFilled");
                    LettersPreceptController.$currentElement.text(selectedValue);
                }
            }
            $("#customCombobox").addClass("hidden");
            $(document).off("click.closeComboBox");
            this.onChanged();
        }));
    }
    addClickHandlers($elements) {
        $elements.find(".selectPointLetter:not(.editable)").on("click", (function(event) {
            event.stopPropagation();
            LettersPreceptController.$currentElement = $(this);
            let offset = LettersPreceptController.$currentElement.offset();
            $("#customCombobox").css({
                top: offset.top + LettersPreceptController.$currentElement.outerHeight(),
                left: offset.left
            }).removeClass("hidden");
            $(document).on("click.closeComboBox", (e => {
                if ($(e.target).closest("#customCombobox").length === 0) {
                    $("#customCombobox").addClass("hidden");
                    $(document).off("click.closeComboBox");
                    this.onChanged();
                }
            }));
        }));
        $elements.find(".selectPointLetterWord:not(:has(.editable))").on("click", (function(e) {
            e.stopPropagation();
            $(this).find(".selectPointLetter").click();
        }));
        $elements.find(".selectPointLetterWord:has(.editable)").on("click", (function(e) {
            $(this).find(".selectPointLetter").focus();
        }));
        $elements.find(".selectPointLetterWord .editable").on("input", (() => {
            this.onChanged();
        }));
        this.onChanged();
    }
    getWordPointSelector() {
        return ".selectPointLetter";
    }
    getWordPointElementUserAnswer($el) {
        return $el.hasClass("selectPointLetter") ? $el.text() : $el.find(".selectPointLetter").text();
    }
    buildInstructions($items, pointData) {
        $items.before(`<p class='precept-instructions'>Ты можешь вставлять буквы вместо пропуска.<br/>\n            Слова, в которые ты не вставишь буквы, будут считаться словами с ошибкой.<br/>\n            Если букву вставлять не нужно, поставь точку или минус.</p>`);
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {
        if (questionData.pointAnswer && questionData.pointAnswer.items) {
            let letterElements = $el.find(".selectPointLetter");
            for (let i = 0; i < letterElements.length; i++) {
                let $letterEl = $(letterElements[i]);
                let data = questionData.pointAnswer.items[i];
                if (data.a) {
                    $letterEl.text(data.a);
                }
            }
        }
    }
}

class LettersWithKeyNumbersPointsController extends PreceptPointsWordController {
    parseWords(htmlIterator) {
        return htmlIterator.findWordsByRegEx(/([а-яё]+)(\(\d*\))([а-яё]+)/giu, 1, 2);
    }
    parsePointWords(pointData) {
        let pointWords = [];
        for (const match of pointData.pointsText.matchAll(/(\{\}\s*([а-яё]+)(\(\d+\))|([а-яё]+)\{\})([а-яё]+)/giu)) {
            if (match[3]) {
                pointWords.push(match[0].replaceAll("{}", "").trim());
            } else {
                pointWords.push(match[0].replaceAll("{}", "()").trim());
            }
        }
        return pointWords;
    }
    buildWordUi(htmlIterator, word, questionData, idx) {
        let element = htmlIterator.wrapSelectedText(word.tokenStart, word.tokenStart, "span", "selectPointLetter");
        let el = $(element);
        el.data("questionId", questionData.questionId);
        el.data("questionNumber", questionData.questionNumber);
        el.data("idx", idx);
        el.data("word", word.word);
        htmlIterator.wrapSelectedText(word.tokenStart, word.tokenEnd, "span", "keyedToken");
        htmlIterator.wrapSelectedText(word.start, word.end, "span", "selectKeyedLetters preceptPointWord");
    }
    buildElementUI(element, questionData, pointData) {
        super.buildElementUI(element, questionData, pointData);
        this.addClickHandlers($(element));
    }
    addClickHandlers($elements) {
        let that = this;
        $elements.find(".selectKeyedLetters").click((function(e) {
            e.stopPropagation();
            that.toggleElementState($(this).find(".selectPointLetter"));
        }));
        $elements.find(".selectPointLetter").click((function(e) {
            e.stopPropagation();
            that.toggleElementState($(this));
        }));
    }
    toggleElementState($element) {
        let [questionData, pointData] = this.getElementData($element);
        if (!pointData) return;
        let currentText = $element.text().toLowerCase();
        let idx = pointData.options.indexOf(currentText);
        if (idx < 0) {
            $element.text(pointData.options[0]);
        } else if (idx < pointData.options.length - 1) {
            $element.text(pointData.options[idx + 1]);
        } else {
            $element.text("");
        }
        this.onChanged();
    }
    getWordPointSelector() {
        return ".selectPointLetter";
    }
    getWordPointElementUserAnswer($el) {
        return $el.hasClass("selectPointLetter") ? $el.text() : $el.find(".selectPointLetter").text();
    }
    buildInstructions($items, pointData) {
        $items.before(`<p class='precept-instructions'>Ты можешь выбирать Н или НН вставить вместо пропуска, нажимая на слово несколько раз.<br/> \nСлова, в которые ты не вставишь буквы, будут считаться словами с ошибкой.</p>`);
    }
    fillQuestionExtrasAndPreceptPoints($el, questionData, type) {
        if (questionData.pointAnswer && questionData.pointAnswer.items) {
            let letterElements = $el.find(".selectPointLetter");
            for (let i = 0; i < letterElements.length; i++) {
                let $letterEl = $(letterElements[i]);
                let data = questionData.pointAnswer.items[i];
                if (data.a) {
                    $letterEl.text(data.a);
                }
            }
        }
    }
}

class WordData {
    constructor(word, tokenStart, tokenEnd, start, end) {
        this.word = word;
        this.tokenStart = tokenStart;
        this.tokenEnd = tokenEnd;
        this.start = start;
        this.end = end;
    }
}

class HtmlIterator {
    constructor(element) {
        this.element = element;
        this.rebuildTextNodes();
        this.index = -1;
        this.offset = -1;
    }
    rebuildTextNodes() {
        this.textNodes = [];
        this.collectTextNodes(this.element);
    }
    collectTextNodes(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            this.textNodes.push(node);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            node.childNodes.forEach((child => this.collectTextNodes(child)));
        }
    }
    next() {
        if (this.index >= this.textNodes.length - 1 && this.offset >= this.textNodes[this.index].nodeValue.length) {
            return {
                value: null,
                done: true
            };
        }
        if (this.index === -1 || this.offset >= this.textNodes[this.index].nodeValue.length) {
            this.index++;
            this.offset = -1;
        }
        this.offset++;
        const char = this.textNodes[this.index].nodeValue[this.offset];
        return {
            value: char,
            done: false,
            index: this.index,
            offset: this.offset
        };
    }
    previous() {
        if (this.index < 0 && this.offset <= 0) {
            return {
                value: null,
                done: true
            };
        }
        if (this.offset <= 0) {
            this.index--;
            this.offset = this.textNodes[this.index].nodeValue.length;
        }
        this.offset--;
        const char = this.textNodes[this.index].nodeValue[this.offset];
        return {
            value: char,
            done: false,
            index: this.index,
            offset: this.offset
        };
    }
    getCurrentPosition() {
        return {
            index: this.index,
            offset: this.offset
        };
    }
    setPosition(position) {
        this.index = position.index;
        this.offset = position.offset;
    }
    setIndex(index) {
        this.setPosition(this.indexToPosition(index));
    }
    positionToIndex(position) {
        let index = 0;
        for (let i = 0; i < position.index; i++) {
            index += this.textNodes[i].nodeValue.length;
        }
        index += position.offset;
        return index;
    }
    indexToPosition(index) {
        let charCount = 0;
        for (let i = 0; i < this.textNodes.length; i++) {
            const length = this.textNodes[i].nodeValue.length;
            if (charCount + length > index) {
                return {
                    index: i,
                    offset: index - charCount
                };
            }
            charCount += length;
        }
        return {
            index: this.textNodes.length - 1,
            offset: this.textNodes[this.textNodes.length - 1].nodeValue.length
        };
    }
    wrapSelectedText(start, end, tag, tagClass) {
        const range = document.createRange();
        let charCount = 0;
        let started = false;
        for (let i = 0; i < this.textNodes.length; i++) {
            const textNode = this.textNodes[i];
            const length = textNode.nodeValue.length;
            if (!started && charCount + length > start) {
                range.setStart(textNode, start - charCount);
                started = true;
            }
            if (!started && i === this.textNodes.length - 1) {
                range.setStart(textNode, start - charCount);
                started = true;
            }
            if (started && charCount + length >= end) {
                range.setEnd(textNode, end - charCount);
                break;
            }
            charCount += length;
        }
        const wrapper = document.createElement(tag);
        wrapper.className = tagClass;
        try {
            range.surroundContents(wrapper);
            this.rebuildTextNodes();
            return wrapper;
        } catch (e) {
            console.error(e);
        }
    }
    getFullText() {
        return this.textNodes.map((node => node.nodeValue)).join("");
    }
    getText(startPosition, endPosition) {
        const startIndex = Number.isInteger(startPosition) ? startPosition : this.positionToIndex(startPosition);
        const endIndex = Number.isInteger(endPosition) ? endPosition : this.positionToIndex(endPosition);
        let charCount = 0;
        let text = "";
        for (const textNode of this.textNodes) {
            const length = textNode.nodeValue.length;
            if (charCount + length > startIndex && charCount < endIndex) {
                const start = Math.max(startIndex - charCount, 0);
                const end = Math.min(endIndex - charCount, length);
                text += textNode.nodeValue.substring(start, end);
            }
            charCount += length;
        }
        return text;
    }
    findAllOccurrences(token) {
        const text = this.getFullText();
        const positions = [];
        let position = text.indexOf(token);
        while (position !== -1) {
            positions.push(position);
            position = text.indexOf(token, position + 1);
        }
        return positions;
    }
    moveForwardToWordBound() {
        let charInfo;
        while (!(charInfo = this.next()).done) {
            const char = charInfo.value;
            if (char === undefined || /\s|\p{P}/u.test(char)) {
                return this.getCurrentPosition();
            }
        }
    }
    moveBackwardToWordBound() {
        let charInfo;
        while (!(charInfo = this.previous()).done) {
            const char = charInfo.value;
            if (char === undefined || /\s|\p{P}/u.test(char)) {
                this.next();
                return this.getCurrentPosition();
            }
        }
    }
    findWordsByRegEx(regex, matchContentBeforeTokenGroupIdx, tokenGroupIdx) {
        const words = [];
        const text = this.getFullText();
        let matcher = text.matchAll(regex);
        for (const match of matcher) {
            let startIdx = match.index;
            let endIdx = match.index + match[0].length;
            let tokenStartIdx = startIdx + match[matchContentBeforeTokenGroupIdx].length;
            let tokenEndIDx = tokenStartIdx + match[tokenGroupIdx].length;
            words.push(new WordData(match[0], tokenStartIdx, tokenEndIDx, startIdx, endIdx));
        }
        return words;
    }
    findWords(token) {
        const words = [];
        let positions = this.findAllOccurrences(token);
        for (let idx in positions) {
            let tokenStartIndex = positions[idx];
            let tokenEndIndex = tokenStartIndex + token.length - 1;
            this.setIndex(tokenStartIndex);
            let wordStartPosition = this.moveBackwardToWordBound();
            this.setIndex(tokenEndIndex);
            let wordEndPosition = this.moveForwardToWordBound();
            let word = this.getText(wordStartPosition, wordEndPosition);
            words.push(new WordData(word, tokenStartIndex, tokenEndIndex, this.positionToIndex(wordStartPosition), this.positionToIndex(wordEndPosition)));
        }
        for (let i = 0; i < words.length; i++) {
            let firstWord = words[i];
            for (let j = i + 1; j < words.length; ++j) {
                if (words[j].start > words[j - 1].end) {
                    if (j > i + 1) {
                        let lastWord = words[j - 1];
                        let text = this.getText(firstWord.start, lastWord.end);
                        for (let k = i; k < j; ++k) {
                            let w = words[k];
                            w.start = firstWord.start;
                            w.end = lastWord.end;
                            w.word = text;
                            i = j;
                        }
                    }
                    break;
                }
            }
        }
        return words;
    }
}

class PreceptPointAnswer {
    constructor(idx, word, answer) {
        this.i = idx;
        this.w = word;
        this.a = answer;
    }
}

class PreceptPointsQuestionAnswer {
    constructor(questionId, questionNumber) {
        this.questionId = questionId;
        this.questionNumber = questionNumber;
        this.items = [];
    }
}

class PreceptPointsUserAnswer {
    constructor() {
        this.data = [];
    }
    append(itemData, answer) {
        let item = this.findQuestionData(itemData.questionId, itemData.questionNumber);
        if (!item) {
            item = new PreceptPointsQuestionAnswer(itemData.questionId, itemData.questionNumber);
            this.data.push(item);
        }
        item.items.push(new PreceptPointAnswer(itemData.idx, itemData.word, answer));
    }
    findQuestionData(questionId, questionNumber) {
        for (let item of this.data) {
            if (item.questionId === questionId) return item;
            if (item.questionId === 0 && item.questionNumber === questionNumber) {
                return item;
            }
        }
        return null;
    }
}

class PreceptWordWithMarkdown {
    constructor(word, markdownStart, hasMarkdown) {
        this.word = word;
        this.markdownStart = markdownStart;
        this.markdownEnd = false;
        this.hasMarkdown = hasMarkdown;
    }
}

class MarkdownHintsController extends PreceptPointsController {
    constructor(questionDataGetter, preceptPointGetter) {
        super(questionDataGetter, preceptPointGetter);
        this.wordRegex = /([а-яёa-z“”"'«»‟„‚‘’()-]+)/giu;
        this.preceptWordRegex = /([а-яёa-z“”"'«»‟„‚‘’()-]+|\{\})/giu;
    }
    buildElementUI(element, questionData, pointData) {
        super.buildElementUI(element, questionData, pointData);
        let htmlIterator = new HtmlIterator(element);
        let words = this.parseWords(htmlIterator);
        if (words.length === 0) return;
        for (let word of words) {
            word.word = word.word.replaceAll("­", "");
        }
        let pointWords = this.parsePointWords(pointData);
        for (let i in pointWords) {
            pointWords[i].word = pointWords[i].word.replaceAll("­", "");
        }
        this.fillWordFlags(words, pointWords);
        let pairs = this.findMarkdownStartEnd(words);
        for (let i = pairs.length - 1; i >= 0; i--) {
            let pair = pairs[i];
            let startWord = pair[0];
            let endWord = pair[1];
            htmlIterator.wrapSelectedText(startWord.start, endWord.end, "span", "hint-mark");
        }
    }
    findMarkdownStartEnd(words) {
        let result = [];
        let start = null;
        for (let i = 0; i < words.length; i++) {
            let word = words[i];
            if (!start && word.hasMarkdown) {
                start = word;
            } else if (start && !word.hasMarkdown) {
                result.push([ start, words[i - 1] ]);
                start = null;
            }
        }
        if (start) {
            result.push([ start, words[words.length - 1] ]);
        }
        return result;
    }
    fillWordFlags(words, pointWords) {
        let aligner = new LevensteinWordAligner((a => a.word), (b => b.word));
        let alignment = aligner.buildAlignment(words, pointWords);
        for (const [i, j] of alignment) {
            if (i != null && j != null) {
                const word = words[i];
                const pointWord = pointWords[j];
                word.markdownStart = pointWord.markdownStart;
                word.markdownEnd = pointWord.markdownEnd;
                word.hasMarkdown = pointWord.hasMarkdown;
            } else if (i != null) {
                const word = words[i];
                word.missingPointWord = true;
            }
        }
        for (let i = 0; i < words.length; i++) {
            const word = words[i];
            if (word.missingPointWord) {
                let prev = this.findPrevNonMissingWord(words, i);
                let next = this.findNextNonMissingWord(words, i);
                if (prev && prev.hasMarkdown) {
                    word.hasMarkdown = true;
                    if (next && !next.hasMarkdown) {
                        word.markdownEnd = true;
                    }
                } else if (next && next.hasMarkdown) {
                    word.hasMarkdown = true;
                    word.markdownStart = true;
                }
            }
        }
    }
    findPrevNonMissingWord(words, idx) {
        for (let i = idx - 1; i >= 0; i--) {
            const word = words[i];
            if (!word.missingPointWord) {
                return word;
            }
        }
        return null;
    }
    findNextNonMissingWord(words, idx) {
        for (let i = idx + 1; i < words.length; ++i) {
            const word = words[i];
            if (!word.missingPointWord) {
                return word;
            }
        }
        return null;
    }
    buildInstructions($items, pointData) {
        $items.before("<p class='suggest-hint'><a>Показать подсказку</a>.</p>");
        $items.closest(".freebirdFormviewerComponentsQuestionBaseRoot").find(".suggest-hint a").click((function(e) {
            $(this).closest(".freebirdFormviewerComponentsQuestionBaseRoot").toggleClass("showHint");
        }));
    }
    parseWords(htmlIterator) {
        return htmlIterator.findWordsByRegEx(this.wordRegex, 1, 1);
    }
    parsePointWords(pointData) {
        let pointWords = [];
        let hasMarkdown = false;
        let prevHasMarkdown = false;
        for (const match of pointData.pointsText.matchAll(this.preceptWordRegex)) {
            let word = match[1];
            if (word === "{}") {
                prevHasMarkdown = hasMarkdown;
                hasMarkdown = !hasMarkdown;
                if (!hasMarkdown && pointWords.length > 0) {
                    pointWords[pointWords.length - 1].markdownEnd = true;
                }
                continue;
            }
            let markdownStart = hasMarkdown && !prevHasMarkdown;
            pointWords.push(new PreceptWordWithMarkdown(word, markdownStart, hasMarkdown));
        }
        return pointWords;
    }
}