class ArraySplit {
    constructor(fieldName, fieldValue) {
        this.items = [];
        this.fieldValue = fieldValue;
        this.fieldName = fieldName;
    }
    static splitArrayByField(array, fieldName) {
        let splitMap = new Map;
        for (const item of array) {
            let key = item[fieldName];
            let collection = splitMap.get(key);
            if (collection === undefined) {
                collection = new ArraySplit(fieldName, key);
                splitMap.set(key, collection);
            }
            collection.items.push(item);
        }
        return Array.from(splitMap.values());
    }
}

function myDoGetDOM(url, forceHtml, that) {
    let defer = $.Deferred();
    let report = function(data) {
        let ownerDocument = document.implementation.createHTMLDocument("virtual");
        let pageDom = $("<xxx></xxx>", ownerDocument).append($(data, ownerDocument));
        if (that !== undefined) defer.resolveWith(that, pageDom); else defer.resolve(pageDom);
    };
    if (forceHtml) {
        $.ajax({
            url: url,
            type: "GET",
            dataType: "html",
            headers: {
                "x-requested-with": ""
            },
            success: report,
            error: function(error) {
                if (that !== undefined) defer.rejectWith(that, error); else defer.reject(error);
            }
        });
    } else {
        $.ajaxSetup({
            timeout: 3e4
        });
        $.get(url).then(report);
    }
    return defer.promise();
}

const html = (strings, ...values) => String.raw({
    raw: strings
}, ...values);

function findMaxInputIntValue(inputs) {
    let max = 0;
    for (let i = 0; i < inputs.length; ++i) {
        if (inputs[i].value > max) {
            max = Number.parseInt(inputs[i].value);
        }
    }
    return max;
}

function findMaxObjectFieldIntValue(objArr, fieldName) {
    let max = 0;
    for (const item of objArr) {
        if (item[fieldName] > max) {
            max = Number.parseInt(item[fieldName]);
        }
    }
    return max;
}

function makeId(length) {
    let result = "";
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    let counter = 0;
    while (counter < length) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
        counter += 1;
    }
    return result;
}

function sleep(timeMs) {
    return new Promise((resolve => setTimeout(resolve, timeMs)));
}

function isOldSafari() {
    const ua = navigator.userAgent;
    const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    if (isSafari) {
        const versionMatch = ua.match(/Version\/(\d+(\.\d+)?)/);
        if (versionMatch) {
            const version = parseFloat(versionMatch[1]);
            return version < 15;
        }
    }
    return false;
}

const isDeepEqual = (object1, object2) => {
    const objKeys1 = Object.keys(object1);
    const objKeys2 = Object.keys(object2);
    if (objKeys1.length !== objKeys2.length) return false;
    for (var key of objKeys1) {
        const value1 = object1[key];
        const value2 = object2[key];
        const isObjects = isObject(value1) && isObject(value2);
        if (isObjects && !isDeepEqual(value1, value2) || !isObjects && value1 !== value2) {
            return false;
        }
    }
    return true;
};

const isObject = object => object != null && typeof object === "object";

function getEventTargetOfSelector(e, selector) {
    let $el = $(e.target);
    return $el.is(selector) ? $el : $el.closest(selector);
}

const ReadFileMode = Object.freeze({
    Buffer: "Buffer",
    Text: "Text"
});

bUtil = {
    blockElements: [ "ADDRESS", "ARTICLE", "ASIDE", "BLOCKQUOTE", "DETAILS", "DIALOG", "DD", "DIV", "DL", "DT", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HR", "LI", "MAIN", "NAV", "OL", "P", "PRE", "SECTION", "UL" ],
    loadScript: function(src, isModule = false) {
        return new Promise((resolve => {
            const script = document.createElement("script");
            script.src = src;
            if (isModule) {
                script.type = "module";
            }
            script.addEventListener("load", resolve);
            document.head.appendChild(script);
        }));
    },
    readFile: function(file, mode) {
        return new Promise(((resolve, reject) => {
            let reader = new FileReader;
            reader.onload = function(loadEvent) {
                let arrayBuffer = loadEvent.target.result;
                resolve(arrayBuffer);
            };
            reader.onerror = function(errorEvent) {
                reject(errorEvent.target.error);
            };
            switch (mode) {
              case ReadFileMode.Buffer:
                reader.readAsArrayBuffer(file);
                return;

              case ReadFileMode.Text:
                reader.readAsText(file, "utf-8");
                return;

              default:
                reject("Bad parse mode: " + mode);
            }
        }));
    },
    readFileInputAsArrayBuffer: function(file) {
        return this.readFile(file, ReadFileMode.Buffer);
    },
    readDocxToHtml: function(file) {
        return bUtil.readFileInputAsArrayBuffer(file).then((arrayBuffer => mammoth.convertToHtml({
            arrayBuffer: arrayBuffer
        })));
    },
    getGlobalLoadScript: function(globalName, fallbackScriptUrl) {
        if (typeof window[globalName] === "undefined") {
            return bUtil.loadScript(fallbackScriptUrl).then((function() {
                return window[globalName];
            }));
        } else {
            return new Promise((resolve => {
                resolve(window[globalName]);
            }));
        }
    },
    loadDocxToHtml: async function(file) {
        const [mammoth, arrayBuffer] = await Promise.all([ bUtil.getGlobalLoadScript("mammoth", "/js/lib/mammoth.browser.min.js"), bUtil.readFileInputAsArrayBuffer(file) ]);
        var options = {
            styleMap: [ "u => u" ]
        };
        return mammoth.convertToHtml({
            arrayBuffer: arrayBuffer
        }, options);
    },
    loadDocxToHtml2: async function(file) {
        function transformParagraph(element) {
            const copy = Object.assign({}, element);
            if (element.alignment === "center" && !element.styleId) {
                copy.styleId = "text-center";
                return copy;
            } else if (element.alignment === "both") {
                copy.styleId = "text-justify";
                return copy;
            } else if (element.alignment === "right") {
                copy.styleId = "text-right";
                return copy;
            } else {
                return element;
            }
        }
        const [mammoth, arrayBuffer] = await Promise.all([ bUtil.getGlobalLoadScript("mammoth", "/js/lib/mammoth.browser.min.js"), bUtil.readFileInputAsArrayBuffer(file) ]);
        var options = {
            styleMap: [ "u => u", "strike => s", "b => b", "i => i", "p.text-center => p.text-center:fresh", "p.text-justify => p.text-justify:fresh", "p.text-right => p.text-right:fresh" ],
            transformDocument: mammoth.transforms.paragraph(transformParagraph)
        };
        return mammoth.convertToHtml({
            arrayBuffer: arrayBuffer
        }, options);
    },
    htmlToDom: function(html) {
        let ownerDocument = document.implementation.createHTMLDocument("virtual");
        return $("<xxx></xxx>", ownerDocument).append($(html.value, ownerDocument));
    },
    getFileOfField: function(fieldId) {
        return new Promise(((resolve, reject) => {
            if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                reject("The File APIs are not fully supported in this browser.");
                return;
            }
            var input = document.getElementById(fieldId);
            if (!input) {
                reject("Um, couldn't find the fileinput element.");
            } else if (!input.files) {
                reject("This browser doesn't seem to support the `files` property of file inputs.");
            } else if (!input.files[0]) {
                reject("Please select a file before clicking 'Load'");
            } else {
                resolve(input.files[0]);
            }
        }));
    },
    getFileOfElement: function(input) {
        return new Promise(((resolve, reject) => {
            if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                reject("The File APIs are not fully supported in this browser.");
                return;
            }
            if (!input) {
                reject("Um, couldn't find the fileinput element.");
            } else if (!input.files) {
                reject("This browser doesn't seem to support the `files` property of file inputs.");
            } else if (!input.files[0]) {
                reject("Please select a file before clicking 'Load'");
            } else {
                resolve(input.files[0]);
            }
        }));
    },
    isBlockElement: function(node) {
        return bUtil.blockElements.includes(node.nodeName);
    },
    extractTextWithLineBreaks: function(elementsJq) {
        let text = "";
        let listItemCounter = 1;
        function traverse(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                text += node.textContent.trim();
            } else if (bUtil.isBlockElement(node)) {
                text += "\n";
                if (node.nodeName === "LI") {
                    text += listItemCounter++ + ". ";
                } else if (node.nodeName === "OL") {
                    listItemCounter = 1;
                }
            } else if (node.nodeName === "BR") {
                text += "\n";
            }
            if (node.childNodes) {
                for (let i = 0; i < node.childNodes.length; i++) {
                    traverse(node.childNodes[i]);
                }
            }
        }
        for (let i = 0; i < elementsJq.length; ++i) {
            traverse(elementsJq[i]);
        }
        return text;
    },
    levenshteinDistance: async function(str1, str2) {
        const m = str1.length;
        const n = str2.length;
        if (m < n) {
            return this.levenshteinDistance(str2, str1);
        }
        if (m === 0) return n;
        if (n === 0) return m;
        const dp = [];
        for (let i = 0; i <= n; i++) {
            dp.push(i);
        }
        for (let i = 1; i <= m; i++) {
            let prev = i - 1;
            let diagonal = prev;
            dp[0] = i;
            for (let j = 1; j <= n; j++) {
                let temp = dp[j];
                if (str1.charAt(i - 1) !== str2.charAt(j - 1)) {
                    dp[j] = Math.min(diagonal, Math.min(dp[j - 1], dp[j])) + 1;
                } else {
                    dp[j] = diagonal;
                }
                diagonal = temp;
            }
        }
        return dp[n];
    },
    toString(obj) {
        let result = "";
        for (const key in obj) {
            if (obj[key] !== undefined && obj[key] !== 0) {
                if (result.length > 0) result += ",";
                result += key;
                result += "=";
                result += obj[key];
            }
        }
        return result;
    },
    parseRegExpQuery(src) {
        let match = src.match(new RegExp("^/(.*?)/([gimysuv]*)$"));
        if (match) {
            return new RegExp(match[1], match[2]);
        } else {
            return src;
        }
    },
    encodeHtmlEntities(str) {
        return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    },
    asyncTimeout(timeoutMs) {
        return new Promise((resolve => {
            setTimeout(resolve, timeoutMs);
        }));
    },
    toCssSize(value) {
        return Number.isFinite(value) ? value + "px" : value;
    },
    isLandscape() {
        let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        let vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        return vw > vh;
    },
    awaitAnimationFrame() {
        return new Promise((resolve => {
            requestAnimationFrame(resolve);
        }));
    },
    isEmail(value) {
        if (typeof value !== "string") {
            return false;
        }
        return !!value.toLowerCase().match(/^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i);
    },
    fixHoverPosition(e) {
        if (!window.POPUP_POS_HELPER) window.POPUP_POS_HELPER = new PopupPositionHelper2;
        let $el = $(e.target);
        if (!$el.is(".hover-host")) {
            $el = $el.closest(".hover-host");
            if (!$el.is(".hover-host")) {
                return;
            }
        }
        let $menu = $el.find(".parent-hover-visible, .hover-popup");
        let limitingCont = $el.closest(".limiting-cont");
        window.POPUP_POS_HELPER.positionPopup($menu[0], $el[0], limitingCont[0]);
    },
    parseUrl(url) {
        var m = (url || sp.targetUrl()).match(/^(([^:\/?#]+:)?(?:\/\/((?:([^\/?#:]*)(?::([^\/?#:]*))?@)?([^\/?#:]*)(?::([^\/?#:]*))?)))?([^?#]*)(\?[^#]*)?(#.*)?$/), r = {
            hash: m[10] || "",
            host: m[3] || "",
            hostname: m[6] || "",
            href: m[0] || "",
            origin: m[1] || "",
            pathname: m[8] || (m[1] ? "/" : ""),
            port: m[7] || "",
            protocol: m[2] || "",
            search: m[9] || "",
            username: m[4] || "",
            password: m[5] || ""
        };
        if (r.protocol.length == 2) {
            r.protocol = "file:///" + r.protocol.toUpperCase();
            r.origin = r.protocol + "//" + r.host;
        }
        r.href = r.origin + r.pathname + r.search + r.hash;
        return r;
    },
    getOrigin() {
        let origin = window.location.origin;
        if (!origin) {
            let location = bUtil.parseUrl(document.documentURI);
            origin = location.origin;
        }
        return origin;
    },
    networkErrorStatusToMessage(status) {
        if (status === "timeout") {
            return "Превышено время ожидания ответа от сервера. Попробуйте еще раз позже. Если ошибка повторяется, свяжитесь с поддержкой.";
        } else if (status === "error") {
            return "Не удалось подключиться к серверу. Проверьте подключение к интернету или повторите попытку позже. Если ошибка повторяется, свяжитесь с поддержкой.";
        } else if (status === "abort") {
            return "Запрос был прерван. Попробуйте снова. Если ошибка повторяется, свяжитесь с поддержкой.";
        } else if (status === "parsererror") {
            return "Ошибка обработки ответа от сервера. Свяжитесь с поддержкой.";
        } else {
            return `<p>Неизвестная ошибка: ${status}. Попробуйте позже. Если ошибка повторяется, свяжитесь с поддержкой.`;
        }
    },
    scrollIntoViewIfNeeded($target, options) {
        options = options ? options : {};
        let $win = $($target[0].ownerDocument.defaultView), $container = options.$container ? options.$container : $win, padding = options.padding ? options.padding : 20, elemTop = $target.offset().top, elemHeight = $target.outerHeight(), containerTop = $container.scrollTop(), containerHeight = $container.outerHeight(), winTop = $win.scrollTop(), winBot = winTop + $win.height(), containerVisibleTop = containerTop < winTop ? winTop : containerTop, containerVisibleBottom = containerTop + containerHeight > winBot ? winBot : containerTop + containerHeight, containerVisibleHeight = containerVisibleBottom - containerVisibleTop;
        if (elemTop < containerTop) {
            if (options.instant) {
                $container.scrollTop(elemTop - padding);
            } else {
                $container.animate({
                    scrollTop: elemTop - padding
                }, options.animationOptions);
            }
        } else if (elemTop + elemHeight > containerTop + containerVisibleHeight) {
            if (options.instant) {
                $container.scrollTop(elemTop + elemHeight - containerVisibleHeight + padding);
            } else {
                $container.animate({
                    scrollTop: elemTop + elemHeight - containerVisibleHeight + padding
                }, options.animationOptions);
            }
        }
    }
};

class FullscreenLogger {
    constructor() {
        this.container = $('<div class="logger"></div>').appendTo("body");
        const closeButton = $('<button class="logger-close-btn">&times;</button>').appendTo(this.container).on("click", (() => {
            this.hide();
        }));
        this.content = $('<div class="logger-content"></div>').appendTo(this.container);
    }
    addLine(text) {
        const line = $(`<p>${text}</p>`);
        this.content.append(line);
        this.container.scrollTop(this.container[0].scrollHeight);
    }
    show() {
        $("body").css("overflow", "hidden");
        this.container.show();
    }
    hide() {
        $("body").css("overflow", "auto");
        this.container.hide();
    }
}

const LOGGER = new FullscreenLogger;

class DocDataConfigBase {
    constructor() {
        this.dataFieldNames = [];
    }
}

class DocDataParser {
    constructor(newItemConfigField, configFields, dataFields, config) {
        this.configFields = {};
        this.dataFields = {};
        this.updates = [];
        this.fieldParsers = new Map;
        this.newItemConfigField = newItemConfigField.toLowerCase();
        for (const key in configFields) {
            this.configFields[key.toLowerCase()] = configFields[key];
        }
        if (this.configFields["fields"] === undefined) {
            this.configFields["fields"] = "dataFieldNames";
        }
        if (Array.isArray(dataFields)) {
            for (const dataField of dataFields) {
                this.dataFields[dataField.toLowerCase()] = dataField;
            }
        } else {
            for (const key in dataFields) {
                this.dataFields[key.toLowerCase()] = dataFields[key];
            }
        }
        this.config = config;
        this.config.dataFieldNames = Array.from(Object.keys(this.dataFields));
    }
    onNewItemTag(tagText) {
        this.mergeLatestUpdateFields();
        this.latestUpdate = this.createNewItem(tagText);
        this.updates.push(this.latestUpdate);
        this.currentField = this.config.dataFieldNames[0];
    }
    mergeLatestUpdateFields() {
        if (!this.latestUpdate) return;
        for (const key of Object.keys(this.latestUpdate)) {
            if (Array.isArray(this.latestUpdate[key])) {
                this.latestUpdate[key] = this.isPlainTextOnlyField(key) ? RichLine.toPlainText(this.latestUpdate[key]) : RichLine.toPlainTextOrHtml(this.latestUpdate[key]);
            }
        }
    }
    isPlainTextOnlyField(field) {
        return false;
    }
    createNewItem(tagText) {
        return {};
    }
    parseText(text) {
        let lines = text.split("\n");
        const optionsPattern = /^\[(.*)\](.*)/;
        for (let line of lines) {
            let optionMatch = optionsPattern.exec(line);
            if (optionMatch) {
                this.updateFromOptions(optionMatch[1]);
                line = optionMatch[2];
                if (line === undefined || line.length < 1) {
                    continue;
                }
            }
            this.addLineToUpdate(line);
        }
        return [ this.config, this.updates ];
    }
    updateFromOptions(optionsStr) {
        let [name, v] = optionsStr.split(/[=;,]/);
        let nameLower = name.trim().toLowerCase();
        if (nameLower === this.newItemConfigField) {
            this.onNewItemTag(optionsStr);
        } else if (this.configFields[nameLower] !== undefined) {
            this.updateConfig(optionsStr);
        } else if (this.dataFields[nameLower] !== undefined) {
            this.currentField = this.dataFields[nameLower];
        }
    }
    parseLines(lines) {
        const optionsPattern = /^\[(.*)\](.*)/;
        for (let line of lines) {
            let optionMatch = optionsPattern.exec(line.plainText);
            if (optionMatch) {
                this.updateFromOptions(optionMatch[1]);
                let text = optionMatch[2];
                if (text === undefined || text.trim().length < 1) {
                    continue;
                }
                let newLine = new RichLine(line.line, text.trim(), line.isHtml);
                if (line.isHtml) {
                    newLine.line = line.line.replace(/^(<.*?>)\[(.*)\]\s*/, "$1");
                } else {
                    newLine.line = newLine.plainText;
                }
                line = newLine;
            }
            this.addRichLineToUpdate(line);
        }
        this.mergeLatestUpdateFields();
        return [ this.config, this.updates ];
    }
    updateConfig(optionText) {
        let [name, value] = optionText.split("=");
        let nameLower = name.trim().toLowerCase();
        this.updateConfigValue(optionText, nameLower, value);
    }
    updateConfigValue(optionText, nameLower, value) {
        let val = value.trim();
        if (val.length === 0) val = value;
        switch (nameLower) {
          case "fields":
            this.config.dataFieldNames = [];
            let fieldNames = val.split(",");
            for (let fieldName of fieldNames) {
                fieldName = fieldName.trim();
                if (this.dataFields[fieldName.toLowerCase()] !== undefined) {
                    this.config.dataFieldNames.push(this.dataFields[fieldName.toLowerCase()]);
                }
            }
            return;
        }
        if (this.fieldParsers.has(nameLower)) {
            this.config[this.configFields[nameLower]] = this.fieldParsers.get(nameLower)(val);
            return;
        }
        this.config[this.configFields[nameLower]] = val;
    }
    addLineToUpdate(line) {
        if (this.latestUpdate === undefined || this.currentField === undefined) return;
        line = line.trim();
        if (this.latestUpdate[this.currentField]) {
            this.latestUpdate[this.currentField] = this.latestUpdate[this.currentField] + "\n" + line;
        } else if (line.length > 0) {
            this.latestUpdate[this.currentField] = line;
        }
    }
    addRichLineToUpdate(line) {
        if (this.latestUpdate === undefined || this.currentField === undefined) return;
        if (this.latestUpdate[this.currentField]) {
            this.latestUpdate[this.currentField].push(line);
        } else if (line.plainText.length > 0) {
            this.latestUpdate[this.currentField] = [ line ];
        }
    }
}

class UpdateResult {
    constructor(isOk, candidates, update, error) {
        this.ok = isOk;
        this.candidates = candidates;
        this.update = update;
        this.error = error;
    }
    isOk() {
        return this.ok;
    }
}

class UpdateWithCandidates {
    constructor(update, candidates) {
        this.update = update;
        this.candidates = candidates;
    }
}

class ItemsFromDocxUpdater {
    constructor() {
        this.progressJQ = $(".update-file-counter");
    }
    doUpdateFromFile(fieldName) {
        let that = this;
        this.publishProgressText("Loading file");
        let extractor = new RichLinesExtractor;
        return bUtil.getFileOfField(fieldName).then(bUtil.loadDocxToHtml2).then(bUtil.htmlToDom).then(extractor.extract.bind(extractor)).then((lines => {
            that.publishProgressText("Parsing text");
            let result = that.parseLines(lines);
            if (result[1].length !== 0) {
                return result;
            }
            return that.parseText(RichLine.toPlainText(lines));
        })).then((([config, updates]) => that.findCandidatesForItems(config, updates))).then((([config, updates, updateCandidates]) => that.applyCandidates(config, updates, updateCandidates))).then((results => that.printUpdateResult(results)));
    }
    async findCandidatesForItems(config, updates) {
        let updateCandidates = [];
        for (let i = 0; i < updates.length; ++i) {
            let update = updates[i];
            let candidates = null;
            try {
                candidates = await this.findCandidates(config, update);
                updateCandidates.push(new UpdateWithCandidates(update, candidates));
                this.publishProgress(i + 1, 0, updates.length);
            } catch (e) {
                console.log(e);
                result.push(new UpdateResult(false, candidates, update, e));
            }
        }
        return [ config, updates, updateCandidates ];
    }
    publishProgress(findCount, updateCount, totalCount) {
        this.publishProgressText(`${findCount}/${updateCount}/${totalCount}`);
    }
    publishProgressText(text) {
        this.progressJQ.text(text);
    }
    async applyCandidates(config, updates, updateCandidates) {
        let result = [];
        for (let i = 0; i < updateCandidates.length; ++i) {
            let updCnd = updateCandidates[i];
            let update = updCnd.update;
            let candidates = updCnd.candidates;
            try {
                if (candidates.length === 1) {
                    await this.applyItemUpdate(candidates[0], update, config);
                    result.push(new UpdateResult(true, candidates, update));
                } else if (candidates.length === 0) {
                    result.push(await this.applyNewItem(update, config));
                } else {
                    result.push(new UpdateResult(false, candidates, update));
                }
            } catch (e) {
                console.log(e);
                result.push(new UpdateResult(false, candidates, update, e));
            }
            this.publishProgress(updates.length, i + 1, updateCandidates.length);
        }
        return result;
    }
    parseText(text) {
        return [ new DocDataConfigBase, [] ];
    }
    parseLines(lines) {
        return [ new DocDataConfigBase, [] ];
    }
    async findCandidates(config, update) {
        return [];
    }
    async applyItemUpdate(candidate, update, config) {}
    async applyNewItem(update, config) {
        return new UpdateResult(false, [], update);
    }
    printUpdateResult(updateResult) {
        let hasChanged = false;
        let hasFailed = false;
        for (let item of updateResult) {
            if (item.isOk()) {
                hasChanged = true;
            } else {
                hasFailed = true;
            }
        }
        if (hasChanged) {
            $("#saveAllButton").removeAttr("disabled");
        }
        if (hasFailed) {
            LOGGER.show();
            for (let item of updateResult) {
                if (item.isOk()) {
                    continue;
                }
                let update = item.update;
                if (update.simplify) {
                    update = update.simplify();
                }
                let message = "Failed: " + bUtil.toString(update) + ":<br/>\n";
                if (item.error != null) {
                    message += "Error: " + item.error;
                } else if (item.candidates !== null && item.candidates.length < 1) {
                    message += "Не найден элемент для обновления";
                } else if (item.candidates !== null && item.candidates.length > 1) {
                    message += "Несколько кандидатов на обновление: ";
                    for (let candidate of item.candidates) {
                        message += "№" + candidate.question.number + "(id=" + candidate.question.storedId + ")," + "factor=" + candidate.factor;
                    }
                }
                LOGGER.addLine(message);
            }
        }
        return [ hasChanged, hasFailed ];
    }
}

(function() {
    $.fn.nextUntilWithTextNodes = function(until) {
        let matched = $.map(this, (function(elem, i, until) {
            let matched = [];
            while ((elem = elem.nextSibling) && elem.nodeType !== 9) {
                if (elem.nodeType === 1 || elem.nodeType === 3) {
                    if (until && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        }), until);
        return this.pushStack(matched);
    };
    jQuery.each([ "put", "delete", "head", "patch" ], (function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    }));
    $.extend($.expr[":"], {
        containsExact: $.expr.createPseudo ? $.expr.createPseudo((function(text) {
            return function(elem) {
                return $.trim(elem.innerHTML.toLowerCase()) === text.toLowerCase();
            };
        })) : function(elem, i, match) {
            return $.trim(elem.innerHTML.toLowerCase()) === match[3].toLowerCase();
        },
        containsExactCase: $.expr.createPseudo ? $.expr.createPseudo((function(text) {
            return function(elem) {
                return $.trim(elem.innerHTML) === text;
            };
        })) : function(elem, i, match) {
            return $.trim(elem.innerHTML) === match[3];
        },
        containsRegex: $.expr.createPseudo ? $.expr.createPseudo((function(text) {
            var reg = /^\/((?:\\\/|[^\/])+)\/([mig]{0,3})$/.exec(text);
            return function(elem) {
                return reg ? RegExp(reg[1], reg[2]).test($.trim(elem.innerHTML)) : false;
            };
        })) : function(elem, i, match) {
            var reg = /^\/((?:\\\/|[^\/])+)\/([mig]{0,3})$/.exec(match[3]);
            return reg ? RegExp(reg[1], reg[2]).test($.trim(elem.innerHTML)) : false;
        }
    });
})();

class DocxBuilder {
    constructor() {
        this.paragraphs = [];
    }
    appendText(text, size = 24) {
        this.paragraphs.push(new docx.Paragraph({
            children: [ new docx.TextRun({
                text: text,
                size: size
            }) ]
        }));
    }
    save(fileName) {
        const doc = new docx.Document({
            sections: [ {
                properties: {},
                children: this.paragraphs
            } ]
        });
        docx.Packer.toBlob(doc).then((blob => {
            saveAs(blob, fileName);
        }));
    }
}

class Gravity {
    constructor(name) {
        this.name = name;
    }
    applyX(x = 0, width = 0) {
        switch (this) {
          case Gravity.Left:
            return [ x, x + width ];

          case Gravity.Right:
            return [ x - width, x ];

          case Gravity.Center:
            let left = x - width / 2;
            return [ left, left + width ];
        }
        return [ x, x + width ];
    }
    fixInsideWindowX(left, right, windowPadding = 16) {
        let minX = windowPadding;
        let docWidth = $(document).width() - 1;
        let maxX = docWidth - windowPadding;
        if (right - left >= maxX - minX) {
            return [ windowPadding, windowPadding ];
        }
        if (left < minX) {
            return [ minX, docWidth - (minX + (right - left)) ];
        }
        if (right > maxX) {
            return [ maxX - (right - left), docWidth - maxX ];
        }
        return [ left, docWidth - right ];
    }
}

Gravity.Left = new Gravity("left");

Gravity.Right = new Gravity("right");

Gravity.Center = new Gravity("center");

async function showToastBelow(element, text, durationMs) {
    let rect = element.getBoundingClientRect();
    let left = (rect.left + rect.right) / 2;
    let top = window.scrollY + rect.bottom + 20;
    showToast(text, left, top, durationMs, Gravity.Center);
}

async function showToast(text, posX, posY, durationMs, gravity = Gravity.Center) {
    let toast = $(`<div class='toast' style='top: ${posY}px'>${text}</div>`);
    $("body").append(toast);
    let rect = toast[0].getBoundingClientRect();
    let [left, right] = gravity.applyX(posX, rect.width);
    [left, right] = gravity.fixInsideWindowX(left, right);
    toast.css({
        left: left,
        right: right,
        "animation-duration": durationMs + "ms"
    });
    await sleep(durationMs + 10);
    toast.remove();
}

const PreceptPointBehavior = {
    Unknown: "Unknown",
    CommasWithKeyNumbers: "CommasWithKeyNumbers",
    Commas: "Commas",
    Letters: "Letters",
    TogetherSeparately: "TogetherSeparately",
    LettersWithKeyNumbers: "LettersWithKeyNumbers",
    MultiSelectPrecept: "MultiSelectPrecept",
    LettersInText: "LettersInText",
    TermMatch: "TermMatch",
    FixWord: "FixWord",
    ReplaceWordInMarkup: "ReplaceWordInMarkup",
    CategoryPreceptKeyMatch: "CategoryPreceptKeyMatch",
    MultiTypePointsInText: "MultiTypePointsInText"
};

function resolvePointBehavior(egeNumber) {
    if (!PRECEPT_RESOLUTION_MAP) return PreceptPointBehavior.Unknown;
    egeNumber = Number.parseInt(egeNumber);
    let result = PRECEPT_RESOLUTION_MAP[egeNumber];
    return result ? result : PreceptPointBehavior.Unknown;
}

class ViewAnimator {
    collapse($item, childFilter, toWidth, toHeight) {
        $item.addClass("collapsing");
        return new Promise((resolve => {
            if ($item.css("max-width") === "none") {
                $item.css({
                    maxWidth: $item[0].scrollWidth + "px",
                    maxHeight: $item[0].scrollHeight + "px"
                });
                const that = this;
                requestAnimationFrame((() => {
                    that.doAnimateCollapse($item, childFilter, toWidth, toHeight, resolve);
                }));
            } else {
                this.doAnimateCollapse($item, childFilter, toWidth, toHeight, resolve);
            }
        }));
    }
    collapseHeight($item, childFilter) {
        return this.collapse($item, childFilter, "", 0);
    }
    expandHeight($item, childFilter) {
        return this.expand($item, childFilter, undefined, 0, "100%");
    }
    collapseWidth($item, childFilter) {
        return this.collapse($item, childFilter, 0, "");
    }
    expandWidth($item, childFilter, toValue) {
        return this.expand($item, childFilter, 0, undefined, toValue, undefined);
    }
    doAnimateCollapse($item, childFilter, toWidth, toHeight, resolve) {
        $item.children(childFilter).each((function() {
            const $child = $(this);
            $child.css({
                width: $child.outerWidth() + "px"
            });
        }));
        $item.css({
            maxWidth: this.toSizeValue(toWidth),
            maxHeight: this.toSizeValue(toHeight)
        });
        this.ensureTransitionEndStopPropagation($item);
        $item.one("transitionend", (function() {
            $item.removeClass("collapsing");
            resolve();
        }));
    }
    toSizeValue(value) {
        if (typeof value === "undefined") {
            return "";
        }
        if (Number.isFinite(value)) return value + "px";
        return value;
    }
    shouldSetFirst($item, attr, value) {
        if (typeof value === "undefined") return false;
        return $item.css(attr) === "none";
    }
    expand($item, childFilter, startWidth, startHeight, toWidthVal, toHeightVal) {
        $item.removeClass("collapsing");
        return new Promise((resolve => {
            toWidthVal = toWidthVal !== undefined ? toWidthVal : $item[0].scrollWidth + "px";
            toHeightVal = toHeightVal !== undefined ? toHeightVal : $item[0].scrollHeight + "px";
            if (this.shouldSetFirst($item, "max-width", startWidth) || this.shouldSetFirst($item, "max-height", startHeight)) {
                $item.css("transition", "none");
                this.doSetStartSize($item, startWidth, startHeight);
                const that = this;
                requestAnimationFrame((() => {
                    $item.css("transition", "");
                    requestAnimationFrame((() => {
                        that.doAnimateExpand($item, childFilter, toWidthVal, toHeightVal, resolve);
                    }));
                }));
            } else {
                this.doAnimateExpand($item, childFilter, toWidthVal, toHeightVal, resolve);
            }
        }));
    }
    setCssNoTransition($item, cssObject) {
        cssObject.transition = "none";
        $item.css(cssObject);
        return new Promise((resolve => {
            requestAnimationFrame((() => {
                $item.css("transition", "");
                requestAnimationFrame((() => {
                    resolve();
                }));
            }));
        }));
    }
    doSetStartSize($item, startWidth, startHeight) {
        if (typeof startWidth !== "undefined") {
            $item.css("max-width", this.toSizeValue(startWidth));
        }
        if (typeof startHeight !== "undefined") {
            $item.css("max-height", this.toSizeValue(startHeight));
        }
    }
    doAnimateExpand($item, childFilter, toWidthVal, toHeightVal, resolve) {
        this.ensureTransitionEndStopPropagation($item);
        $item.one("transitionend", (function() {
            $item.children(childFilter).each((function() {
                $(this).css({
                    width: ""
                });
            }));
            $item.css({
                "max-width": "",
                "max-height": ""
            });
            resolve();
        }));
        $item.css({
            maxWidth: toWidthVal,
            maxHeight: toHeightVal
        });
    }
    ensureTransitionEndStopPropagation($item) {
        $item.children().each(((idx, el) => {
            const $el = $(el);
            if ($el.data("transitionend-propagation-stopped") !== "yes") {
                $el.data("transitionend-propagation-stopped", "yes");
                $el.on("transitionend", (function(event) {
                    event.stopPropagation();
                }));
            }
        }));
    }
}

const VIEW_ANIMATOR = new ViewAnimator;

class ProgressBar {
    constructor(container, steps = []) {
        this.$container = $(container);
        this.steps = steps;
        this.stepFlags = [];
        for (let i in steps) {
            this.stepFlags[i] = false;
        }
        this.currentStep = -1;
        this.render();
    }
    render() {
        this.$container.empty();
        let progressBar = $('<div class="progress-bar"></div>');
        this.steps.forEach(((step, index) => {
            progressBar.append($(`<div class="progress-step"><div class="step-circle" data-step="${step}"></div></div>`));
        }));
        this.$container.append(progressBar);
    }
    setCurrentStep(stepIndex) {
        let stepElements = this.$container.find(".progress-step");
        this.stepFlags[stepIndex] = !this.stepFlags[stepIndex];
        stepElements.removeClass("current completed completedOk completedFail");
        for (let idx = 0; idx < stepIndex; ++idx) {
            stepElements.eq(idx).addClass("completed").addClass(this.stepFlags[idx] ? "completedOk" : "completedFail");
        }
        stepElements.eq(stepIndex).addClass("current");
        this.currentStep = stepIndex;
    }
    completeStep(success) {
        let stepElements = this.$container.find(".progress-step");
        this.stepFlags[this.currentStep] = success;
        stepElements.eq(this.currentStep).removeClass("current").addClass("completed").addClass(success ? "completedOk" : "completedFail");
    }
    advance() {
        if (this.currentStep < this.steps.length - 1) {
            this.setCurrentStep(this.currentStep + 1);
        }
    }
    previousStep() {
        if (this.currentStep > 0) {
            this.setCurrentStep(this.currentStep - 1);
        }
    }
    isVisibleOnScreen() {
        let rect = this.$container[0].getBoundingClientRect();
        let viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
        if (rect.height < viewHeight) {
            return rect.top >= 0 && rect.bottom <= viewHeight;
        }
        return !(rect.bottom < 0 || rect.top - viewHeight >= 0);
    }
    getScrollIntoViewDistance() {
        let rect = this.$container[0].getBoundingClientRect();
        if (rect.top < 0) return -rect.top;
        let viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
        if (rect.height < viewHeight) {
            return rect.bottom <= viewHeight ? 0 : rect.top;
        }
        return !(rect.bottom < 0 || rect.top - viewHeight >= 0) ? 0 : Math.abs(rect.top);
    }
    scrollIntoView() {
        this.$container[0].scrollIntoView({
            behavior: "smooth",
            block: "start",
            inline: "center"
        });
    }
}

function applyAccountSelector($sel, filterFn = undefined) {
    if (!window.GlobalCache) {
        window.GlobalCache = {};
    }
    $sel.select2({
        placeholder: "Выберите аккаунт",
        minimumInputLength: 0,
        width: "style",
        ajax: {
            url: "/api/teacher/getAccounts",
            dataType: "json",
            delay: 250,
            transport: function(params, success, failure) {
                const cacheKey = "availableAccounts";
                if (window.GlobalCache[cacheKey]) {
                    success(window.GlobalCache[cacheKey]);
                    return undefined;
                } else {
                    const request = $.ajax(params);
                    request.done((function(data) {
                        window.GlobalCache[cacheKey] = data;
                        success(data);
                    })).fail(failure);
                    return request;
                }
            },
            processResults: function(reply) {
                return {
                    results: (filterFn ? reply.data.filter(filterFn) : reply.data).map((account => ({
                        id: account.id,
                        text: account.name
                    })))
                };
            }
        }
    });
}

class InputRow {
    constructor(container) {
        this.container = container;
        this.errorMessage = container.querySelector(".error-message");
        let $cont = $(container);
        if (!this.errorMessage) {
            this.errorMessage = $('<span class="error-message"></span>')[0];
            $cont.append(this.errorMessage);
        }
        this.onChange((() => this.clearError()));
    }
    showError(message) {
        this.container.classList.add("error");
        this.errorMessage.textContent = message;
    }
    clearError() {
        this.container.classList.remove("error");
        this.errorMessage.textContent = "";
    }
    scrollIntoView() {
        this.container.scrollIntoView({
            behavior: "smooth",
            block: "start",
            inline: "center"
        });
    }
    onChange(callback) {
        let $cont = $(this.container);
        $cont.find("input").on("input", callback);
        $cont.find("select").on("change", callback);
    }
    setVisible(isVisible) {
        let $cont = $(this.container);
        if (isVisible) $cont.removeClass("hidden"); else $cont.addClass("hidden");
    }
}

class MaterialTextInput extends InputRow {
    constructor(container) {
        super(container);
        this.input = container.querySelector("input");
        this.label = container.querySelector("label");
    }
    getValue() {
        return this.input.value;
    }
    setValue(value) {
        this.input.value = value;
        this.clearError();
    }
    setEnabled(enabled) {
        let $el = $(this.input);
        if (enabled) $el.removeAttr("disabled"); else $el.attr("disabled", true);
    }
}

class PopupHelper {
    constructor(popupSelector, selector = undefined) {
        this.popupSelector = popupSelector;
        this.scrollbarWidth = this.getScrollbarWidth();
        if (selector) {
            this.handleCells(selector);
        }
    }
    handleCells(selector, $container = undefined) {
        const that = this;
        let $el = $container ? $container.find(selector) : $(selector);
        $el.mouseover((e => that.fixPosition(e, selector, this.popupSelector))).click((function(e) {
            if ($(this).hasClass("selected")) {
                $(this).removeClass("selected");
            } else {
                $("td.selected").removeClass("selected");
                $(this).addClass("selected");
            }
        }));
        that.addStopPropagation($el.find(".popUpInfo"));
    }
    addStopPropagation($el) {
        $el.click((e => {
            e.stopPropagation();
            return true;
        }));
    }
    fixPosition(e, targetSelector, popUpSelector) {
        let target = $(e.target);
        if (!target.is(targetSelector)) {
            target = target.closest(targetSelector);
        }
        let popUpJq = target.find(popUpSelector);
        if (popUpJq.length < 1) return;
        let popUp = popUpJq[0];
        let tdRect = target[0].getBoundingClientRect();
        if (tdRect.right + popUp.offsetWidth > window.innerWidth - this.scrollbarWidth) {
            if (this.myRandom === undefined) {
                this.myRandom = Math.random() * 10;
            }
            let dist = tdRect.right - (window.innerWidth - this.scrollbarWidth) + this.myRandom;
            popUp.style.right = dist + "px";
            popUp.style.left = "unset";
        } else {
            popUp.style.left = null;
            popUp.style.right = null;
        }
        if (tdRect.bottom + popUp.offsetHeight > window.innerHeight) {
            popUp.style.bottom = "100%";
            popUp.style.top = "unset";
        } else {
            popUp.style.top = null;
            popUp.style.bottom = null;
        }
    }
    getScrollbarWidth() {
        const outer = document.createElement("div");
        outer.style.visibility = "hidden";
        outer.style.overflow = "scroll";
        outer.style.msOverflowStyle = "scrollbar";
        document.body.appendChild(outer);
        const inner = document.createElement("div");
        outer.appendChild(inner);
        const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
        outer.parentNode.removeChild(outer);
        return scrollbarWidth;
    }
}

class PopupPositionHelper2 {
    constructor() {
        this.viewportPadding = 10;
        this.scrollbarWidth = this.getScrollbarWidth();
    }
    attachPopup(popup, anchor) {
        if (!popup || !anchor) return;
        this.positionPopup(popup, anchor);
        window.addEventListener("resize", (() => this.positionPopup(popup, anchor)));
    }
    positionPopup(popup, anchor, limitingContainer) {
        if (!popup) return;
        const anchorRect = anchor.getBoundingClientRect();
        let rootTop = anchorRect.top;
        let oldDisplay = popup.style.display;
        popup.style.setProperty("display", "none", "important");
        let limitingRect = limitingContainer ? this.getRect(limitingContainer) : this.getViewportRect();
        popup.style.display = oldDisplay;
        popup.style.height = "";
        popup.style.width = "";
        popup.style["overflow-y"] = "";
        let popupWidth = this.chooseWidth(popup, limitingRect);
        popup.style.width = `${popupWidth}px`;
        let popupRect = popup.getBoundingClientRect();
        let [top, height] = this.chooseTop(popup, popupRect, anchorRect, limitingRect);
        popup.style.top = `${top - rootTop}px`;
        popup.style.height = height ? `${height}px` : "";
        if (height) {
            popup.style["overflow-y"] = "auto";
            let popupWidth = this.chooseWidth(popup, limitingRect);
            popup.style.width = `${popupWidth}px`;
        }
        let left = this.chooseLeft(anchorRect, popupWidth, limitingRect);
        popup.style.left = `${left}px`;
    }
    chooseLeft(anchorRect, popupWidth, limitingRect) {
        let a = anchorRect.left - limitingRect.left;
        let b = limitingRect.right - anchorRect.right;
        if (popupWidth >= limitingRect.width || a <= 0) {
            return limitingRect.left - anchorRect.left;
        } else if (b <= 0) {
            return limitingRect.right - popupWidth - anchorRect.left;
        }
        let a1 = (limitingRect.width - popupWidth) * a / (a + b);
        return limitingRect.left + a1 - anchorRect.left;
    }
    getViewportRect() {
        return new DOMRectReadOnly(this.viewportPadding, this.viewportPadding, window.innerWidth - 2 * this.viewportPadding - this.scrollbarWidth, window.innerHeight - 2 * this.viewportPadding);
    }
    positionPopupBelow(popup, anchor, positionRoot) {
        if (!popup) return;
        const rootRect = positionRoot.getBoundingClientRect();
        let rootTop = rootRect.top;
        popup.style.height = "";
        popup.style.width = "";
        popup.style["overflow-y"] = "";
        let popupWidth = this.chooseWidth(popup);
        popup.style.width = `${popupWidth}px`;
        const anchorRect = anchor.getBoundingClientRect();
        let popupRect = popup.getBoundingClientRect();
        let [top, height] = this.chooseTop(popup, popupRect, anchorRect);
        popup.style.top = `${top - rootTop}px`;
        popup.style.height = height ? `${height}px` : "";
        if (height) {
            popup.style["overflow-y"] = "auto";
            let popupWidth = this.chooseWidth(popup);
            popup.style.width = `${popupWidth}px`;
        }
        const spaceRight = $(window).width() - anchorRect.right - this.viewportPadding - this.scrollbarWidth;
        let left;
        if (spaceRight >= popupWidth) {
            left = 0;
        } else {
            let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
            vw = Math.min(vw, $(window).width() - this.viewportPadding - this.scrollbarWidth);
            left = Math.max(vw - popupWidth - this.viewportPadding - anchorRect.left - this.scrollbarWidth, this.viewportPadding - anchorRect.left - this.scrollbarWidth);
        }
        popup.style.left = `${left}px`;
        if (left + popupWidth + this.viewportPadding > $(window).width()) {
            popup.style.width = $(window).width() - left - this.viewportPadding + "px";
        }
    }
    getRect(element) {
        let rect = element.getBoundingClientRect();
        if (element.clientWidth < rect.width) {
            new DOMRectReadOnly(rect.left, rect.top, element.clientWidth, element.clientHeight);
        }
        return rect;
    }
    chooseTop(popup, popupRect, anchorRect, limitingRect) {
        if (!limitingRect) limitingRect = this.getViewportRect();
        const spaceAbove = anchorRect.top - limitingRect.top;
        const spaceBelow = limitingRect.bottom - anchorRect.bottom - this.viewportPadding - this.scrollbarWidth;
        if (popupRect.height >= spaceBelow && popupRect.height >= spaceAbove) {
            if (spaceAbove > spaceBelow) {
                return [ anchorRect.top - spaceAbove, spaceAbove ];
            } else {
                return [ anchorRect.bottom, spaceBelow ];
            }
        } else if (spaceBelow >= popupRect.height || spaceBelow >= spaceAbove) {
            return [ anchorRect.bottom, undefined ];
        } else {
            return [ anchorRect.top - popupRect.height, undefined ];
        }
    }
    chooseWidth(popup, limitingRect) {
        if (!limitingRect) limitingRect = this.getViewportRect();
        let [minContentWidth, maxContentWidth] = this.measureMinMaxContentWidth(popup);
        const popupStyle = window.getComputedStyle(popup);
        let maxWidthStr = popupStyle.getPropertyValue("--max-popup-width");
        let minWidthStr = popupStyle.getPropertyValue("--min-popup-width");
        if (maxWidthStr === "min-content") return minContentWidth;
        if (minWidthStr === "max-content") return maxContentWidth;
        let minWidth = parseInt(minWidthStr || "300", 10);
        let maxWidth = parseInt(maxWidthStr || "500", 10);
        maxWidth = Math.min(maxWidth, limitingRect.width);
        minWidth = Math.min(minWidth, limitingRect.width);
        if (maxContentWidth < minWidth) return minWidth;
        if (maxContentWidth > maxWidth) return maxWidth;
        return maxContentWidth;
    }
    measureMinMaxContentWidth(popup) {
        let oldWidth = popup.style.width;
        popup.style.width = "max-content";
        let maxWidth = popup.offsetWidth + 1;
        popup.style.width = "min-content";
        let minWidth = popup.offsetWidth + 1;
        popup.style.width = oldWidth;
        return [ minWidth, maxWidth ];
    }
    getScrollbarWidth() {
        const outer = document.createElement("div");
        outer.style.visibility = "hidden";
        outer.style.overflow = "scroll";
        outer.style.msOverflowStyle = "scrollbar";
        document.body.appendChild(outer);
        const inner = document.createElement("div");
        outer.appendChild(inner);
        const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
        outer.parentNode.removeChild(outer);
        return scrollbarWidth;
    }
}

class Plurals {
    constructor(one, some, many) {
        this.one = one;
        this.some = some;
        this.many = many;
    }
    get(amount) {
        let decs = Math.floor(amount / 10) % 10;
        if (decs === 1) return this.many;
        switch (amount % 10) {
          case 1:
            return this.one;

          case 2:
          case 3:
          case 4:
            return this.some;

          default:
            return this.many;
        }
    }
}

class ApiReply {}

class JsonApiTransport {
    async put(apiUrl, data, type = undefined) {
        return new Promise(((resolve, reject) => {
            const jqxhr = $.put(apiUrl, JSON.stringify(data), undefined, type);
            this.applyCallbacksToAjaxRequest(jqxhr, data, resolve, reject);
        }));
    }
    async post(apiUrl, data, type) {
        return this.ajax("post", apiUrl, data, type, "application/json; charset=UTF-8");
    }
    async get(apiUrl, data = {}, type = undefined, options = {}) {
        let urlParams = "";
        if (typeof data === "string") {
            urlParams += data;
        } else if (typeof data === "object") {
            urlParams = Object.keys(data).map((function(key) {
                return encodeURIComponent(key) + "=" + encodeURIComponent(data[key]);
            })).join("&");
        }
        const url = apiUrl.indexOf("?") >= 0 ? apiUrl + "&" + urlParams : apiUrl + "?" + urlParams;
        return new Promise(((resolve, reject) => {
            let req = jQuery.extend({
                url: url,
                type: "GET",
                dataType: type
            }, jQuery.isPlainObject(options) && options);
            const jqxhr = jQuery.ajax(req);
            this.applyCallbacksToAjaxRequest(jqxhr, undefined, resolve, reject);
        }));
    }
    async delete(apiUrl, data = {}, type) {
        const urlParams = Object.keys(data).map((function(key) {
            return encodeURIComponent(key) + "=" + encodeURIComponent(data[key]);
        })).join("&");
        const url = apiUrl.indexOf("?") >= 0 ? apiUrl + "&" + urlParams : apiUrl + "?" + urlParams;
        return new Promise(((resolve, reject) => {
            const jqxhr = $.delete(url, undefined, undefined, type);
            this.applyCallbacksToAjaxRequest(jqxhr, data, resolve, reject);
        }));
    }
    async ajax(method, apiUrl, data, type = undefined, contentType) {
        if (method.toLowerCase() === "get") {
            return this.get(apiUrl, data);
        }
        return new Promise(((resolve, reject) => {
            let jqxhr = jQuery.ajax({
                url: apiUrl,
                type: method,
                dataType: type,
                data: JSON.stringify(data),
                contentType: contentType
            });
            this.applyCallbacksToAjaxRequest(jqxhr, data, resolve, reject);
        }));
    }
    applyCallbacksToAjaxRequest(jqxhr, requestData, resolve, reject) {
        jqxhr.done((function(replyStr) {
            const reply = typeof replyStr === "object" ? replyStr : JSON.parse(replyStr);
            if (reply.errorCode === 200) {
                resolve(reply, requestData);
            } else {
                reject(reply, requestData);
            }
        })).fail((function(jqXHR, textStatus, errorThrown) {
            reject({
                status: "error",
                errorCode: 0,
                message: textStatus,
                errorThrown: errorThrown
            }, requestData);
        }));
    }
}

const API_TRANSPORT = new JsonApiTransport;

class JsonApiUseCase {
    constructor(method, apiUrl, data) {
        this.method = method;
        this.apiUrl = apiUrl;
        this.dto = data;
        this.noRequestBody = false;
    }
    async exec() {
        if ("delete" === this.method.toLowerCase() && this.noRequestBody) {
            return API_TRANSPORT.delete(this.apiUrl, this.dto, "json");
        }
        if ("get" === this.method.toLowerCase() && this.noRequestBody) {
            return API_TRANSPORT.get(this.apiUrl, this.dto);
        }
        return API_TRANSPORT.ajax(this.method, this.apiUrl, this.dto, "json", "application/json; charset=UTF-8");
    }
}

class JsonApiReplyUseCase extends JsonApiUseCase {
    async exec() {
        let result = await super.exec();
        return result.data;
    }
}

class JsonApiUseCaseWithDialog extends JsonApiUseCase {
    constructor(method, apiUrl, data) {
        super(method, apiUrl, data);
        this.basicTemplate = '<div class="simple-dialog"><div class="dialog-body"><div class="dialog-message"></div></div></div>';
    }
    initDefaultDialog(title) {
        return this.init$Dialog($(this.basicTemplate), title);
    }
    initDialog(dialogSelector, title) {
        return this.init$Dialog($(dialogSelector).clone().removeClass("hidden"), title);
    }
    init$Dialog($dialog, title) {
        this.$dialog = $dialog.dialog({
            title: title,
            autoOpen: false,
            closeOnEscape: true,
            modal: true,
            resizable: true,
            width: "auto",
            buttons: {
                Ok: this.onOkClick.bind(this),
                "Отмена": function() {
                    $(this).dialog("close");
                }
            },
            close: this.onClose.bind(this)
        });
        return this.$dialog;
    }
    showDialog() {
        this.$dialog.dialog("open");
    }
    onClose() {
        this.$dialog.remove();
    }
    close() {
        this.$dialog.dialog("close");
    }
    onOkClick() {}
}

class SimpleDialog {
    showWithTemplate(template, title, maxWidth) {
        let $dialog = $(template);
        this.$dialog = $dialog.dialog({
            title: title,
            autoOpen: false,
            closeOnEscape: true,
            modal: true,
            resizable: true,
            width: "auto",
            buttons: this.buildButtons(),
            close: this.onClose.bind(this),
            create: function(event, ui) {
                if (maxWidth) {
                    $(this).parent().css("maxWidth", maxWidth);
                }
            }
        });
        this.$dialog.dialog("open");
        return this.$dialog;
    }
    onClose() {
        this.$dialog.remove();
    }
    buildButtons() {
        return {
            Ok: function() {
                $(this).dialog("close");
            }
        };
    }
}

class SimpleYesNoDialog extends SimpleDialog {
    async showAsync(title, message, yesText, noText, maxWidth) {
        return new Promise(((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.showWithTemplate(message, title, yesText, noText, maxWidth);
        }));
    }
    showWithTemplate(message, title, yesText, noText, maxWidth) {
        this.yesText = yesText;
        this.noText = noText;
        return super.showWithTemplate(`<p>${message}</p>`, title, maxWidth);
    }
    buildButtons() {
        let that = this;
        let buttons = {};
        buttons[this.yesText] = function() {
            that.resolve.call(undefined, true);
            $(this).dialog("close");
        };
        buttons[this.noText] = function() {
            that.resolve.call(undefined, false);
            $(this).dialog("close");
        };
        return buttons;
    }
    onClose() {
        super.onClose();
        this.resolve.call(undefined, false);
    }
}

class ScriptedHoverMenu {
    constructor() {
        let that = this;
        let $body = $("body");
        $body.on("mouseenter", ".hover-host", (function() {
            that.showMenu($(this));
        })).on("mouseleave", ".hover-host, .popup-menu-manual", (function(e) {
            const $relatedTarget = $(e.relatedTarget);
            if (!$relatedTarget.closest(".hover-host").length && !$relatedTarget.closest(".test-menu-content").length) {
                that.hideMenu();
            }
        }));
        $(document).on("click", (function(e) {
            if (that.$menu && !$(e.target).closest(".hover-host, .popup-menu-manual").length) {
                that.hideMenu();
            }
        }));
    }
    buildMenuForTestResult(continueResultUrl) {}
    build$Menu($host) {}
    getContainer($host) {}
    showMenu($host) {
        const $test = this.getContainer($host);
        const windowWidth = window.innerWidth;
        if (this.$menu) {
            this.$menu.remove();
        }
        this.$menu = this.build$Menu($host);
        $test.append(this.$menu);
        const hostPosition = $host.position();
        if (windowWidth >= 800) {
            this.$menu.css({
                position: "absolute",
                top: hostPosition.top + $host.outerHeight() + "px",
                left: hostPosition.left + "px",
                zIndex: 10,
                display: "block"
            });
        } else {
            this.$menu.css({
                position: "absolute",
                top: hostPosition.top + $host.outerHeight() + "px",
                right: $test.outerWidth() - hostPosition.left - $host.outerWidth() + "px",
                zIndex: 10,
                display: "block"
            });
        }
        this.$menu.stop(true, true).fadeIn(200);
    }
    hideMenu() {
        if (this.$menu) {
            this.$menu.remove();
            this.$menu = undefined;
        }
    }
}

class HoverHelpHelper {
    constructor() {
        $((() => {
            this.addHandlers($(".hover-help"));
        }));
    }
    addHandlers($el) {
        $el.click(this.handleClick.bind(this)).on("mouseenter", this.handleHover.bind(this));
    }
    handleHover(e) {
        let $el = $(e.target);
        $el = $el.is(".hover-help") ? $el : $el.closest(".hover-help");
        this.fixPosition($el);
    }
    async handleClick(e) {
        let $el = $(e.target);
        e.preventDefault();
        e.stopPropagation();
        let $cont = $el.is(".hover-help") ? $el : $el.closest(".hover-help");
        if ($el.hasClass("no-click")) {
            this.fixPosition($cont);
            return;
        }
        if (!$cont.hasClass("selected") || $el.is(".hover-help") || $el.hasClass("closeMe")) {
            $cont.toggleClass("selected");
            if ($cont.hasClass("selected")) {
                this.addCloseIfNot($cont);
                this.fixPosition($cont);
            }
        }
        if ($el.hasClass("closeMe")) {
            $cont.css("display", "none");
            await bUtil.awaitAnimationFrame();
            $cont.css("display", "");
        }
    }
    addCloseIfNot($cont) {
        if ($cont.find(".closeMe").length == 0) {
            $($cont.find("> *")[0]).append('<span class="closeMe"></span>');
        }
    }
    fixPosition($cont) {
        if (!window.POPUP_POS_HELPER) window.POPUP_POS_HELPER = new PopupPositionHelper2;
        window.POPUP_POS_HELPER.positionPopup($cont.find(">*")[0], $cont[0]);
    }
}

const HOVER_HELP = new HoverHelpHelper;

class MouseClickHelper {
    constructor() {
        this.startX = 0;
        this.startY = 0;
    }
    getClientCoords(event) {
        let e = event.originalEvent || event;
        if (e.touches && e.touches.length) {
            return {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
        }
        if (e.changedTouches && e.changedTouches.length) {
            return {
                x: e.changedTouches[0].clientX,
                y: e.changedTouches[0].clientY
            };
        }
        return {
            x: e.clientX,
            y: e.clientY
        };
    }
    addClickListener($elements, callback) {
        if (!$elements || !$elements.length || typeof callback !== "function") return;
        $elements.off("mousedown touchstart click touchend").on("mousedown touchstart", (event => {
            let {x: x, y: y} = this.getClientCoords(event);
            this.startX = x;
            this.startY = y;
        })).on("click", (function(event) {
            let {x: x, y: y} = MOUSE_CLICK_HELPER.getClientCoords(event);
            console.log(`dx=${x - MOUSE_CLICK_HELPER.startX}, dy=${y - MOUSE_CLICK_HELPER.startY}`);
            if (MOUSE_CLICK_HELPER.startX && MOUSE_CLICK_HELPER.startY && (Math.abs(x - MOUSE_CLICK_HELPER.startX) > 5 || Math.abs(y - MOUSE_CLICK_HELPER.startY) > 5)) {
                return;
            }
            MOUSE_CLICK_HELPER.startX = null;
            MOUSE_CLICK_HELPER.startY = null;
            callback.call(this, event);
        }));
    }
}

const MOUSE_CLICK_HELPER = new MouseClickHelper;

class LevensteinWordAligner {
    constructor(getWordA, getWordB) {
        this.getWordA = getWordA;
        this.getWordB = getWordB;
    }
    buildAlignment(arrayA, arrayB) {
        let wordsA = arrayA.map(this.getWordA);
        let wordsB = arrayB.map(this.getWordB);
        const dp = this.buildDPTable(wordsA, wordsB);
        return this.traceback(dp, wordsA.length, wordsB.length);
    }
    applyAlignment(alignment, arrayA, arrayB, callback) {
        for (const [i, j] of alignment) {
            if (i != null && j != null) {
                const a = arrayA[i];
                const b = arrayB[j];
                callback.call(null, a, b);
            }
        }
    }
    buildDPTable(wordsA, wordsB) {
        const m = wordsA.length;
        const n = wordsB.length;
        const dp = Array.from({
            length: m + 1
        }, (() => Array.from({
            length: n + 1
        }, (() => ({
            cost: 0,
            prev: null
        })))));
        for (let i = 1; i <= m; i++) dp[i][0] = {
            cost: i,
            prev: [ i - 1, 0 ]
        };
        for (let j = 1; j <= n; j++) dp[0][j] = {
            cost: j,
            prev: [ 0, j - 1 ]
        };
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                const match = wordsA[i - 1] === wordsB[j - 1] ? 0 : 1;
                const options = [ {
                    cost: dp[i - 1][j - 1].cost + match,
                    prev: [ i - 1, j - 1 ]
                }, {
                    cost: dp[i - 1][j].cost + 1,
                    prev: [ i - 1, j ]
                }, {
                    cost: dp[i][j - 1].cost + 1,
                    prev: [ i, j - 1 ]
                } ];
                dp[i][j] = options.reduce(((min, o) => o.cost < min.cost ? o : min));
            }
        }
        return dp;
    }
    traceback(dp, m, n) {
        const alignment = [];
        let i = m, j = n;
        while (i > 0 || j > 0) {
            const {prev: prev} = dp[i][j];
            const [pi, pj] = prev;
            if (i > 0 && j > 0 && pi === i - 1 && pj === j - 1) {
                alignment.push([ i - 1, j - 1 ]);
            } else if (pi === i - 1 && pj === j) {
                alignment.push([ i - 1, null ]);
            } else {
                alignment.push([ null, j - 1 ]);
            }
            i = pi;
            j = pj;
        }
        alignment.reverse();
        return alignment;
    }
}

class RichLine {
    constructor(line, plainText, isHtml) {
        this.line = line;
        this.plainText = plainText;
        this.isHtml = isHtml;
    }
}

RichLine.toPlainText = function(lines) {
    return lines.map((l => l.plainText)).join("\n");
};

RichLine.toHtml = function(lines) {
    return lines.map((l => l.isHtml ? l.line : `<p>${l.plainText}</p>`)).join("");
};

RichLine.toPlainTextOrHtml = function(lines) {
    for (let line of lines) {
        if (line.isHtml) {
            return RichLine.toHtml(lines);
        }
    }
    return RichLine.toPlainText(lines);
};

class RichLinesExtractor {
    extract($elements) {
        this.lines = [];
        this.listItemCounter = 1;
        this.resetLine();
        for (let i = 0; i < $elements.length; i++) {
            this.traverse($elements[i]);
        }
        return this.lines;
    }
    traverse(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            let text = node.textContent;
            this.line += text;
            this.plainText += text;
            return;
        }
        let nodeTag = "";
        if (bUtil.isBlockElement(node)) {
            this.extractCurrentLine(false);
            nodeTag = "\n";
        }
        switch (node.nodeName) {
          case "LI":
            let text = this.listItemCounter++ + ". ";
            this.line += text;
            this.plainText += text;
            nodeTag = "\n";
            break;

          case "OL":
            this.listItemCounter = 1;
            nodeTag = "\n";
            break;

          case "UL":
            nodeTag = "\n";
            break;

          case "BR":
            this.extractCurrentLine(true);
            break;

          case "STRONG":
          case "B":
            this.isHtml = true;
            this.line += "<b>";
            nodeTag = "b";
            break;

          case "EM":
          case "I":
            this.isHtml = true;
            this.line += "<i>";
            nodeTag = "i";
            break;

          case "U":
            this.isHtml = true;
            this.line += "<u>";
            nodeTag = "u";
            break;

          case "P":
            if (node.classList.contains("text-center")) {
                this.pStyles += "text-align: center;";
                this.isHtml = true;
            } else if (node.classList.contains("text-right")) {
                this.pStyles += "text-align: right;";
                this.isHtml = true;
            } else if (node.classList.contains("text-justify")) {
                this.pStyles += "text-align: justify;";
                this.isHtml = true;
            }
            nodeTag = "\n";
        }
        if (node.childNodes) {
            for (let i = 0; i < node.childNodes.length; i++) {
                this.traverse(node.childNodes[i]);
            }
        }
        if (nodeTag === "\n") {
            this.extractCurrentLine(true);
        } else if (nodeTag.length > 0) {
            this.line += `</${nodeTag}>`;
        }
    }
    extractCurrentLine(canAddEmptyLine) {
        if (!canAddEmptyLine && this.line.length === 0) {
            return;
        }
        if (this.isHtml) {
            let style = this.pStyles ? ` style='${this.pStyles}'` : "";
            let line = this.line.trim();
            line = `<p${style}>${line}</p>`;
            this.lines.push(new RichLine(line, this.plainText.trim(), true));
        } else {
            this.lines.push(new RichLine(this.plainText, this.plainText, false));
        }
        this.resetLine();
    }
    resetLine() {
        this.line = "";
        this.plainText = "";
        this.pStyles = "";
        this.isHtml = false;
    }
}