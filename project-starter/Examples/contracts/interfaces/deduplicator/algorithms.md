# Контракт: Алгоритмы дедупликации

## Метаданные
- **Версия**: 1.0.0
- **Статус**: Стабильный
- **Последнее обновление**: 2025-04-15
- **Последний редактор**: AI
- **Ветка разработки**: main

## История изменений
| Дата | Версия | Автор | Описание изменений | PR |
|------|--------|-------|-------------------|-----|
| 2025-04-15 | 1.0.0 | AI | Начальная версия | - |

## Описание
Данный контракт определяет требования к алгоритмам дедупликации, используемым в модуле Deduplicator. Он описывает интерфейсы для различных стратегий блокировки, сравнения и объединения записей.

## Интерфейсы алгоритмов

### BlockingStrategy
```java
/**
 * Интерфейс для стратегий блокировки записей.
 * Блокировка используется для группировки записей по определенным критериям,
 * чтобы уменьшить количество сравнений.
 */
public interface BlockingStrategy {
    /**
     * Группирует записи по блокам для дальнейшего сравнения.
     *
     * @param items Список записей для группировки
     * @return Карта, где ключ - идентификатор блока, значение - список индексов записей в блоке
     *
     * @pre items != null
     * @post result != null
     */
    Map<String, List<Integer>> blockItems(List<JSONObject> items);
}
```

### ItemComparator
```java
/**
 * Интерфейс для сравнения записей.
 */
public interface ItemComparator {
    /**
     * Вычисляет степень сходства между двумя записями.
     *
     * @param item1 Первая запись
     * @param item2 Вторая запись
     * @return Значение от 0.0 до 1.0, где 1.0 означает полное совпадение
     *
     * @pre item1 != null
     * @pre item2 != null
     * @post 0.0 <= result <= 1.0
     */
    double compare(JSONObject item1, JSONObject item2);

    /**
     * Проверяет, являются ли две записи дубликатами.
     *
     * @param item1 Первая запись
     * @param item2 Вторая запись
     * @return true, если записи являются дубликатами, иначе false
     *
     * @pre item1 != null
     * @pre item2 != null
     */
    boolean isDuplicate(JSONObject item1, JSONObject item2);

    /**
     * Возвращает причину, по которой записи считаются дубликатами.
     *
     * @param item1 Первая запись
     * @param item2 Вторая запись
     * @return Строка с описанием причины или null, если записи не являются дубликатами
     *
     * @pre item1 != null
     * @pre item2 != null
     */
    String getDuplicateReason(JSONObject item1, JSONObject item2);
}
```

### DuplicateMerger
```java
/**
 * Интерфейс для объединения дубликатов.
 */
public interface DuplicateMerger {
    /**
     * Объединяет две записи в одну.
     *
     * @param item1 Первая запись
     * @param item2 Вторая запись
     * @return Объединенная запись
     *
     * @pre item1 != null
     * @pre item2 != null
     * @post result != null
     */
    JSONObject merge(JSONObject item1, JSONObject item2);

    /**
     * Объединяет список дубликатов в одну запись.
     *
     * @param items Список дубликатов
     * @return Объединенная запись
     *
     * @pre items != null
     * @pre items.size() > 0
     * @post result != null
     */
    JSONObject mergeAll(List<JSONObject> items);
}
```

## Реализации алгоритмов

### Стратегии блокировки

#### ISBNBlockingStrategy
Группирует записи по нормализованному ISBN.

**Предусловия**:
- Записи должны содержать поле "ISBN" или его эквивалент

**Постусловия**:
- Записи с одинаковым ISBN будут в одном блоке
- Записи без ISBN будут в отдельном блоке

#### SKUBlockingStrategy
Группирует записи по артикулу или SKU.

**Предусловия**:
- Записи должны содержать поле "Артикул", "SKU" или их эквивалент

**Постусловия**:
- Записи с одинаковым артикулом будут в одном блоке
- Записи без артикула будут в отдельном блоке

#### TitlePrefixBlockingStrategy
Группирует записи по префиксу названия.

**Предусловия**:
- Записи должны содержать поле "Название" или его эквивалент
- Должна быть указана длина префикса (по умолчанию 3 символа)

**Постусловия**:
- Записи с одинаковым префиксом названия будут в одном блоке
- Записи с названием короче указанной длины префикса будут в отдельном блоке

#### HybridBlockingStrategy
Комбинирует несколько стратегий блокировки.

**Предусловия**:
- Должен быть указан список стратегий блокировки

**Постусловия**:
- Записи будут сгруппированы по всем указанным стратегиям
- Результаты всех стратегий будут объединены

### Компараторы

#### ExactMatchComparator
Сравнивает записи на основе точного совпадения указанных полей.

**Предусловия**:
- Должен быть указан список полей для сравнения

**Постусловия**:
- Возвращает 1.0, если все указанные поля совпадают
- Возвращает 0.0, если хотя бы одно поле не совпадает

#### FuzzyMatchComparator
Сравнивает записи на основе нечеткого сравнения текстовых полей.

**Предусловия**:
- Должен быть указан список полей для сравнения
- Должен быть указан алгоритм нечеткого сравнения (Jaro-Winkler, Levenshtein и т.д.)
- Должен быть указан порог сходства (от 0.0 до 1.0)

**Постусловия**:
- Возвращает степень сходства от 0.0 до 1.0
- Если степень сходства >= порога, записи считаются дубликатами

#### MinHashComparator
Сравнивает записи на основе MinHash и LSH.

**Предусловия**:
- Должен быть указан размер подписи MinHash
- Должен быть указан размер полосы LSH
- Должен быть указан порог сходства (от 0.0 до 1.0)

**Постусловия**:
- Возвращает степень сходства от 0.0 до 1.0
- Если степень сходства >= порога, записи считаются дубликатами

#### WeightedComparator
Сравнивает записи на основе взвешенного сравнения нескольких полей.

**Предусловия**:
- Должен быть указан список полей для сравнения
- Должны быть указаны веса для каждого поля (сумма весов должна быть равна 1.0)
- Для каждого поля должен быть указан компаратор

**Постусловия**:
- Возвращает взвешенную сумму результатов сравнения по каждому полю
- Если взвешенная сумма >= порога, записи считаются дубликатами

### Объединители дубликатов

#### PriorityFieldMerger
Объединяет дубликаты, выбирая значения полей из записи с более высоким приоритетом.

**Предусловия**:
- Должна быть указана функция определения приоритета записи

**Постусловия**:
- Результат содержит все поля из обеих записей
- При конфликте полей выбирается значение из записи с более высоким приоритетом

#### BestValueMerger
Объединяет дубликаты, выбирая "лучшее" значение для каждого поля.

**Предусловия**:
- Должны быть указаны критерии выбора "лучшего" значения для каждого поля

**Постусловия**:
- Результат содержит все поля из обеих записей
- Для каждого поля выбирается "лучшее" значение согласно указанным критериям

## Примеры использования

```java
// Пример использования стратегии блокировки
BlockingStrategy blockingStrategy = new ISBNBlockingStrategy();
Map<String, List<Integer>> blocks = blockingStrategy.blockItems(items);

// Пример использования компаратора
ItemComparator comparator = new FuzzyMatchComparator(
    Arrays.asList("Название", "Автор"),
    "Jaro-Winkler",
    0.85
);
double similarity = comparator.compare(item1, item2);
boolean isDuplicate = comparator.isDuplicate(item1, item2);

// Пример использования объединителя дубликатов
DuplicateMerger merger = new BestValueMerger(
    Map.of(
        "Название", BestValueCriteria.LONGEST,
        "Цена", BestValueCriteria.LOWEST,
        "Описание", BestValueCriteria.LONGEST
    )
);
JSONObject mergedItem = merger.merge(item1, item2);
```

## Связанные контракты
- [Deduplicator Interface Contract](./contract.md)
- [DeduplicationConfig](./deduplication-config.md)
- [JSON Schema](../../data/json-schema/input-schema.json)
