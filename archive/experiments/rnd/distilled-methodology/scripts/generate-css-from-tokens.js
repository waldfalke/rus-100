#!/usr/bin/env node
/**
 * Generate CSS custom properties from design tokens
 * Usage: node scripts/generate-css-from-tokens.js [input-tokens] [output-css]
 */

const fs = require('fs');
const path = require('path');

function formatValue(token) {
  if (!token || typeof token !== 'object') return null;

  const { value, type, unit } = token;

  // Handle different token types
  switch (type) {
    case 'color':
      return value;
    
    case 'dimension':
      return typeof value === 'number' && unit ? `${value}${unit}` : value;
    
    case 'fontFamily':
      return value;
    
    case 'fontWeight':
    case 'number':
      return value.toString();
    
    case 'shadow':
      return value;
    
    case 'gradient':
    case 'animation':
    case 'transition':
    case 'custom':
      return value;
    
    default:
      return value?.toString() || null;
  }
}

function tokensToCSS(tokens, prefix = '--', indent = '  ') {
  const lines = [];

  function processTokens(obj, path = []) {
    for (const [key, value] of Object.entries(obj)) {
      // Skip metadata and special keys
      if (key === 'metadata' || key === '$description') continue;

      const currentPath = [...path, key];
      const cssVarName = `${prefix}${currentPath.join('-')}`;

      if (value && typeof value === 'object' && 'value' in value) {
        // This is a token value
        const cssValue = formatValue(value);
        if (cssValue !== null) {
          const comment = value.comment ? ` /* ${value.comment} */` : '';
          lines.push(`${indent}${cssVarName}: ${cssValue};${comment}`);
        }
      } else if (value && typeof value === 'object') {
        // Recurse into nested objects
        processTokens(value, currentPath);
      }
    }
  }

  processTokens(tokens);
  return lines;
}

function generateCSS(tokens, includeMetadata = true) {
  const lines = [];

  // Header comment
  if (includeMetadata && tokens.metadata) {
    lines.push('/**');
    lines.push(' * Design Tokens - CSS Custom Properties');
    lines.push(` * Version: ${tokens.metadata.version || 'unknown'}`);
    lines.push(` * Generated: ${tokens.metadata.generated || new Date().toISOString()}`);
    lines.push(` * Generator: ${tokens.metadata.generator || 'generate-css-from-tokens.js'}`);
    lines.push(' * ');
    lines.push(' * WARNING: Do not edit this file directly!');
    lines.push(' * Modify design-tokens/tokens.json and regenerate.');
    lines.push(' */');
    lines.push('');
  }

  // Root CSS variables
  lines.push(':root {');
  const cssVars = tokensToCSS(tokens);
  lines.push(...cssVars);
  lines.push('}');

  return lines.join('\n');
}

function generateDarkTheme(tokens) {
  const lines = [];
  
  lines.push('');
  lines.push('/* Dark theme overrides */');
  lines.push('.dark {');

  // Extract dark theme tokens (tokens with -dark suffix)
  const darkVars = [];
  
  function findDarkTokens(obj, path = []) {
    for (const [key, value] of Object.entries(obj)) {
      if (key === 'metadata' || key === '$description') continue;

      const currentPath = [...path, key];

      if (value && typeof value === 'object' && 'value' in value) {
        // Check if this is a dark variant
        if (key.endsWith('-dark')) {
          const baseKey = key.slice(0, -5); // Remove '-dark' suffix
          const basePath = [...path, baseKey];
          const cssVarName = `--${basePath.join('-')}`;
          const cssValue = formatValue(value);
          
          if (cssValue !== null) {
            const comment = value.comment ? ` /* ${value.comment} */` : '';
            darkVars.push(`  ${cssVarName}: ${cssValue};${comment}`);
          }
        }
      } else if (value && typeof value === 'object') {
        findDarkTokens(value, currentPath);
      }
    }
  }

  findDarkTokens(tokens);

  if (darkVars.length > 0) {
    lines.push(...darkVars);
  } else {
    lines.push('  /* No dark theme tokens defined */');
  }

  lines.push('}');

  return lines.join('\n');
}

function main() {
  const inputPath = process.argv[2] || './design-tokens/tokens.json';
  const outputPath = process.argv[3] || './build/css/variables.css';

  console.log('ğŸ¨ Generating CSS from design tokens...');
  console.log(`ğŸ“¥ Input: ${inputPath}`);
  console.log(`ğŸ“¤ Output: ${outputPath}`);

  // Load tokens
  if (!fs.existsSync(inputPath)) {
    console.error(`âŒ Error: Tokens file not found: ${inputPath}`);
    process.exit(1);
  }

  let tokens;
  try {
    const content = fs.readFileSync(inputPath, 'utf8');
    tokens = JSON.parse(content);
  } catch (err) {
    console.error(`âŒ Error: Failed to parse tokens: ${err.message}`);
    process.exit(1);
  }

  // Generate CSS
  const lightThemeCSS = generateCSS(tokens);
  const darkThemeCSS = generateDarkTheme(tokens);
  const fullCSS = lightThemeCSS + '\n' + darkThemeCSS;

  // Write output
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputPath, fullCSS, 'utf8');

  // Stats
  const varCount = (fullCSS.match(/--[a-z]/g) || []).length;
  console.log(`âœ… Generated ${varCount} CSS custom properties`);
  console.log(`ğŸ“ Output written to: ${outputPath}`);
}

main();
