# contracts/METACONTRACT.yml
# Universal meta-contract for BloggingAgency Contract-Driven Development

id: METACONTRACT-001
title: "Meta-Contract — Rules for Writing Contracts"
version: 1.0
created_at: "2025-10-16"
project: "BloggingAgency"
complexity_level: complex  # Self-referential, governs all contracts

# Self-reference
meta_contract:
  id: "METACONTRACT-001"
  path: "docs/contracts/METACONTRACT.yml"
  version: "1.0"

summary: |
  Universal meta-contract defining structure, invariants, conventions and validation
  rules for all contracts in BloggingAgency project. This is the single source of truth
  for authoring, reviewing and validating contracts (YAML) that govern development work.

# --------------------------
# Core Principles: Contextual Locality & Tokenomics
# --------------------------
# IMPORTANT: These principles are CONSTRAINTS (what NOT to do), not PRESCRIPTIVE (how to do).
# They preserve AI creativity and flexibility while preventing common failure modes.
# Think "rules of the game", not "how to play the game".
#
# Analogy: AI is like a player in "What? Where? When?" game - knows many facts, can combine them.
# Our job: provide constraints and boundaries, not step-by-step instructions.
# Example of good constraint: "Blast Radius" - defines scope boundaries, not implementation.
#
core_principles:
  contextual_locality:
    principle: "Contract must be self-contained and explicit"

    rules:
      no_implicit_knowledge:
        description: "Never assume AI has implicit knowledge beyond contract text"
        why: "AI reading contract may have different context window, no session memory"
        examples:
          bad: "Components don't use hex colors directly"
          good: "Components MUST NOT use hardcoded hex colors (#RRGGBB format). Use design tokens from @tokens/primitives/colors or @tokens/semantic/colors instead."
          bad_explanation: "Assumes AI knows what 'directly' means, what alternatives exist"
          good_explanation: "Explicitly states forbidden pattern AND correct alternative with exact path"

      no_implicit_connections:
        description: "All dependencies and relationships must be explicit"
        why: "AI cannot infer connections between files/concepts outside contract"
        examples:
          bad: "Use ESLint with no-restricted-syntax rule"
          good: "Hardcoded colors detected by ESLint rule in .eslintrc.json: no-restricted-syntax blocks literal patterns: /#[0-9A-Fa-f]{3,6}/, /rgb\\(/, /rgba\\(/, /hsl\\(/, /oklch\\(/ in src/components/**/*.tsx files"
          bad_explanation: "Assumes AI knows which ESLint rule, where it's configured, what it blocks"
          good_explanation: "Explicit: which file, which rule, which patterns, which files"

      no_assumed_context:
        description: "Don't assume reader has access to related files or prior decisions"
        why: "Contract may be loaded without surrounding context due to token budget"
        examples:
          bad: "note: 'Already implemented in .eslintrc'"
          good: "validation_status: 'Implemented in .eslintrc.json (see rules.no-restricted-syntax array, patterns: hex colors, rgb/rgba, hsl/hsla, oklch literals)'"
          bad_explanation: "Assumes reader will check .eslintrc, knows where to look"
          good_explanation: "States exactly what exists, where, and what it contains"

      explicit_token_references:
        description: "All token/file references must include full path and export name"
        why: "AI cannot resolve ambiguous references without full context"
        format: "@tokens/path/to/file#exportName or src/full/path/to/file.ts"
        examples:
          bad: "Use design tokens"
          good: "Import from @tokens/primitives/colors (primitiveColors export) or @tokens/semantic/colors (lightSemanticColors/darkSemanticColors exports)"
          bad: "Use spacing tokens"
          good: "Import primitiveSpacing from @tokens/primitives/spacing (primitiveSpacing constant, values are px numbers: { 0: 0, 1: 4, 2: 8, 4: 16, ... })"

  tokenomics:
    principle: "Efficient use of AI context budget when writing and executing contracts"

    rules:
      progressive_disclosure:
        description: "Contract loads only necessary information"
        why: "Large contracts waste tokens, may exceed context limits"
        guidelines:
          - "Keep contracts focused on single deliverable (component/page/system)"
          - "Reference external files instead of duplicating content"
          - "Use dependency chains (_INDEX.yaml pattern) for complex systems"
          - "Estimated context cost in comments for large sections"

      compression_without_ambiguity:
        description: "Be concise but never ambiguous"
        why: "Verbose contracts waste tokens, but ambiguity causes misinterpretation"
        examples:
          bad_verbose: "This contract defines the rules for the button component which includes all the different variants like primary, secondary, outline, and also all the different states such as hover, active, disabled, loading, and also all the sizing options..."
          bad_ambiguous: "Button follows design system"
          good: "Button component contract. Variants: primary|secondary|outline. States: hover|active|disabled|loading. Sizes: sm|md|lg. Must use buttonTokens from @tokens/semantic/components. WCAG AA compliant (4.5:1 contrast, 44px touch target)."
          good_explanation: "Lists exact options, explicit token reference, key requirements. ~40 tokens vs 100+ verbose or ambiguous interpretation risk"

      explicit_vs_referenced:
        description: "Inline critical info, reference non-critical details"
        why: "Contract must work if external references unavailable"
        critical_inline:
          - "Preconditions (what must exist)"
          - "Postconditions (what must be true after)"
          - "Invariants (always-true constraints)"
          - "Acceptance criteria (how to verify)"
          - "Anti-patterns with examples (what NOT to do)"
        can_reference:
          - "Detailed implementation examples (link to examples/)"
          - "Historical context (link to TaskLogs/)"
          - "Related contracts (link with ID)"
          - "External standards (WCAG 2.2 AA with URL)"

      self_documenting_structure:
        description: "Contract structure itself conveys meaning"
        why: "Reduces need for explanatory prose"
        examples:
          - "Use YAML anchors/aliases for repeated patterns"
          - "Use consistent key ordering (preconditions → postconditions → invariants)"
          - "Use descriptive key names (tokens_used vs deps)"
          - "Group related fields with comments"

  contract_clarity:
    principle: "Every statement must have single unambiguous interpretation"

    note: "These rules define WHAT information must be present, not HOW to implement. AI remains free to choose implementation approach, combine patterns creatively, and find novel solutions within constraints."

    rules:
      no_negation_ambiguity:
        description: "Negative statements often ambiguous, state positive alternative"
        examples:
          bad: "Don't use hardcoded values"
          good: "Use design tokens: import primitiveColors from '@tokens/primitives/colors', import primitiveSpacing from '@tokens/primitives/spacing'"
          bad_explanation: "Doesn't say what TO use, only what NOT to use"

      enumerate_exhaustively:
        description: "For finite sets, list all options explicitly"
        examples:
          bad: "Button variants: primary, secondary, and others"
          good: "Button variants (exhaustive): primary | secondary | outline | ghost | link"
          bad: "Use semantic HTML"
          good: "Use semantic HTML: <button> for actions, <a> for navigation, <input type='submit'> for form submission. Never <div> with onClick for button-like behavior."

      specify_format_and_constraints:
        description: "Always specify data format, allowed range, validation rules"
        examples:
          bad: "Colors in OKLCH"
          good: "Colors in OKLCH format: 'oklch(L C H)' where L=[0-1], C=[0-0.4], H=[0-360]. Example: 'oklch(0.65 0.15 180)' (cyan). Must meet WCAG AA contrast 4.5:1 against background."
          bad: "Spacing follows grid"
          good: "Spacing follows 8-point grid: all values must be multiples of 4px (0, 4, 8, 12, 16, 20, 24...). Stored as px numbers (typeof === 'number'), converted to rem via toRem() utility."

  creativity_preservation:
    principle: "Constraints enable creativity by providing clear boundaries"

    what_is_constrained:
      - "Format and structure of information (MUST be explicit)"
      - "What information must be present (preconditions, postconditions, invariants)"
      - "Scope boundaries (blast radius)"
      - "What NOT to do (anti-patterns)"

    what_is_NOT_constrained:
      - "HOW to implement solution (AI chooses approach)"
      - "Algorithm selection (AI picks best algorithm)"
      - "Code structure and patterns (AI designs architecture)"
      - "Creative problem-solving (AI combines knowledge)"
      - "Optimization strategies (AI experiments and measures)"

    examples:
      constraint_allows_creativity:
        - constraint: "Button must use tokens from @tokens/semantic/components#buttonTokens"
          ai_freedom: "AI chooses: render method, state management, animation approach, event handling, accessibility implementation, performance optimizations"

        - constraint: "Spacing follows 8-point grid (multiples of 4px)"
          ai_freedom: "AI chooses: component layout, composition patterns, responsive breakpoints, grid vs flexbox, nesting strategy"

        - constraint: "Complex domain: Focus works on 95% devices, graceful degradation"
          ai_freedom: "AI experiments with: different camera APIs, fallback strategies, device detection, performance tuning, user feedback mechanisms"

      cynefin_flexibility:
        - domain: "Simple (Button)"
          precision: "High - specify exact variants: primary|secondary|outline"
          ai_freedom: "Implementation details: hooks usage, memoization, render optimization, event delegation"

        - domain: "Complicated (Form validation)"
          precision: "Medium - specify API and constraints, not implementation"
          ai_freedom: "Validation strategy, state management, error handling patterns, performance optimization"

        - domain: "Complex (Camera integration)"
          precision: "Low - specify goals and invariants only"
          ai_freedom: "Full experimental freedom: try approaches, measure results, adapt, discover emergent solutions"

    analogy: "Chess rules don't tell you how to play chess. They define legal moves. Strategy and creativity emerge within constraints. Good players combine patterns in novel ways. Same with AI and contracts."

# --------------------------
# Project-specific context
# --------------------------
project_context:
  name: "BloggingAgency"
  stack:
    - "Next.js 15.5.5 (Pages Router)"
    - "TypeScript (strict mode)"
    - "Tailwind CSS v4"
    - "Design tokens system"
    - "shadcn-ui components"

  architecture:
    - "Design tokens (primitives → semantic → component)"
    - "8-point grid spacing system"
    - "Brand colors: Teal (#005856), Yellow (#FDF000)"
    - "Brand fonts: Inter, Raleway"

  documentation:
    - "docs/TaskLogs/ - История работ (append-only)"
    - "docs/contracts/ - DbC метаконтракты"
    - "docs/local/ - Локальные заметки (gitignored)"
    - "docs/temp/ - Временные файлы"

# --------------------------
# Contract complexity classification
# --------------------------
complexity_levels:
  simple:
    description: "Well-understood, deterministic tasks with clear best practices."
    examples: "Button component, simple validation, static page"
    contract_precision: "High - specify exact implementation"
    required_fields: ["id", "title", "type", "props", "acceptance_criteria"]

  complicated:
    description: "Multiple valid approaches, requires expertise but predictable."
    examples: "Form with validation, data table, token generation, API integration"
    contract_precision: "Medium - specify interface, allow implementation choices"
    required_fields: ["id", "title", "type", "cynefin_domain", "props", "invariants", "acceptance_criteria"]

  complex:
    description: "Emergent outcomes, requires experimentation."
    examples: "Performance optimization, AI integration, real-time collaboration"
    contract_precision: "Low - specify goals, boundaries, invariants only"
    required_fields: ["id", "title", "type", "cynefin_domain", "invariants", "constraints", "evidence_requirements", "acceptance_criteria"]

# --------------------------
# Required top-level fields
# --------------------------
required_fields:
  common_to_all:
    - id               # CONTRACT-NAME-001
    - title            # Human-readable title
    - type             # component | page | utility | service | system
    - version          # Semver or simple version number
    - project          # "BloggingAgency"
    - meta_contract    # Reference to this file
    - description      # What this contract defines
    - preconditions    # What must be true BEFORE (DbC)
    - postconditions   # What must be true AFTER (DbC)
    - invariants       # What must be true ALWAYS (DbC)
    - acceptance_criteria  # How to verify compliance

  conditional_on_complexity:
    simple:
      - props          # Required and optional props
      - variants       # Visual variants
      - states         # Interaction states

    complicated:
      - cynefin_domain # Simple | Complicated | Complex
      - props
      - dependencies   # External dependencies

    complex:
      - cynefin_domain
      - constraints    # Performance, accessibility goals
      - dependencies
      - anti_patterns  # What NOT to do
      - evidence_requirements

# --------------------------
# Contract structure rules
# --------------------------
structure_rules:
  - "IDs follow pattern: CONTRACT-<NAME>-<NNN> (e.g., CONTRACT-BUTTON-001)"
  - "YAML must be valid UTF-8 and YAML 1.2 compliant"
  - "EVERY contract MUST reference this meta-contract"
  - "version follows semver (1.0.0, 1.1.0, 2.0.0)"
  - "project field MUST be 'BloggingAgency'"
  - "description: multi-line, markdown-friendly"
  - "acceptance_criteria: machine-checkable items"
  - "invariants: declarative statements (required for complicated/complex)"

# --------------------------
# Invariants
# --------------------------
base_invariants:
  all_levels:
    - "Contract MUST reference METACONTRACT-001"
    - "No secrets (API keys, credentials) in contracts"
    - "All file paths relative from project root"
    - "Use design system tokens, not hardcoded values"

  simple:
    - "All props must have explicit types"
    - "All variants must be explicitly defined"
    - "Must follow project styling conventions"

  complicated:
    - "All invariants must be testable"
    - "Dependencies must be explicitly listed"
    - "Follow project architecture conventions"

  complex:
    - "Evidence required for all factual claims"
    - "Anti-patterns must include detection and fix"
    - "Goals must be measurable"

# --------------------------
# Acceptance criteria template
# --------------------------
acceptance_template:
  - name: "Schema Validation"
    description: "Contract YAML validates against meta-schema"
    validation: "automated"

  - name: "Type Checking"
    description: "Implementation type-checks with strict mode"
    validation: "automated"
    check: "<project-specific type checker command>"

  - name: "Build Success"
    description: "Production build completes without errors"
    validation: "automated"
    check: "<project-specific build command>"

  - name: "Human Review"
    description: "Contract reviewed and approved"
    validation: "manual"

# --------------------------
# Templates
# --------------------------
templates:
  component_header: |
    id: CONTRACT-<NAME>-001
    title: "<Component Name>"
    type: component
    version: 1.0.0
    project: "BloggingAgency"
    complexity_level: simple | complicated | complex

    meta_contract:
      id: "METACONTRACT-001"
      path: "docs/contracts/METACONTRACT.yml"

    description: |
      <What this component does>

  props_template: |
    props:
      required:
        - name: <propName>
          type: <TypeScript type>
          description: <Description>
      optional:
        - name: <propName>
          type: <TypeScript type>
          default: <default value>
          description: <Description>

  invariant_template: |
    invariants:
      - "<Condition that must ALWAYS be true>"

  precondition_template: |
    preconditions:
      environment:
        - "<Required software/tools/versions>"
        - "<Required configuration>"
      directory_structure:
        - "<Required files/folders that must exist>"
      dependencies:
        - "<Required packages/libraries>"
      state:
        - "<Required system state before operation>"

  postcondition_template: |
    postconditions:
      files:
        - "<Files that must exist after operation>"
        - "<File contents/format requirements>"
      validation:
        - "<Validation scripts that must pass>"
        - "<Quality checks that must succeed>"
      build:
        - "<Build/compilation requirements>"
      architecture:
        - "<Structural requirements after operation>"
      documentation:
        - "<Documentation that must exist>"

# --------------------------
# Meta Anti-patterns (methodology level)
# --------------------------
meta_anti_patterns:
  - pattern: "Vague acceptance criteria"
    example: "looks good, works well, seems fine"
    why_bad: "Subjective, not verifiable, not testable"
    fix: "Specific, measurable criteria with automated checks"

  - pattern: "Code-First, Contract-Later"
    example: "Write implementation, then document it as contract"
    why_bad: "Contract becomes documentation, not source of truth"
    fix: "Contract first, then implement from contract"

  - pattern: "Over-Specification in Complex domain"
    example: "Hardcoded values in contract when solution is emergent"
    why_bad: "Assumes solution is known when it's not"
    fix: "Specify goals and invariants, let implementation emerge"

  - pattern: "Under-Specification in Simple domain"
    example: "Generic types when exact values are known"
    why_bad: "Simple domain solutions are known, be precise"
    fix: "Specify exact types, values, constraints"

  - pattern: "Implicit dependencies"
    example: "Contract doesn't list what it depends on"
    why_bad: "Dependencies not explicit, contract incomplete"
    fix: "Explicitly list all dependencies in contract"

  - pattern: "Untestable acceptance criteria"
    example: "Criteria that can't be automated or measured"
    why_bad: "Can't verify compliance, contract unenforceable"
    fix: "Machine-checkable criteria with validation commands"

  - pattern: "Missing cynefin domain classification"
    example: "No complexity_level or cynefin_domain field"
    why_bad: "Contract precision mismatched to problem complexity"
    fix: "Always classify: Simple, Complicated, or Complex"

  - pattern: "Implicit knowledge assumption"
    example: "Components don't use hex colors directly"
    why_bad: "Assumes AI knows what 'directly' means, what alternatives exist"
    fix: "Components MUST NOT use hardcoded hex colors (#RRGGBB). Use @tokens/primitives/colors (primitiveColors export) or @tokens/semantic/colors (lightSemanticColors/darkSemanticColors exports)"

  - pattern: "Ambiguous references"
    example: "Use ESLint rule", "Already implemented", "See config file"
    why_bad: "AI cannot resolve without full path, rule name, specific location"
    fix: "ESLint rule in .eslintrc.json: rules.no-restricted-syntax blocks /#[0-9A-Fa-f]{3,6}/ in src/components/**/*.tsx"

  - pattern: "Negative without positive alternative"
    example: "Don't use hardcoded values", "Avoid inline styles"
    why_bad: "States what NOT to do, but not what TO do"
    fix: "Use design tokens: import primitiveColors from '@tokens/primitives/colors', import primitiveSpacing from '@tokens/primitives/spacing'"

  - pattern: "Incomplete enumeration"
    example: "Button variants: primary, secondary, and others"
    why_bad: "AI will guess what 'others' means, causing inconsistency"
    fix: "Button variants (exhaustive): primary | secondary | outline | ghost | link"

# --------------------------
# Best practices (universal methodology)
# --------------------------
best_practices:
  - "Write contract BEFORE implementation"
  - "Keep contracts focused on single deliverable"
  - "Prefer machine-checkable criteria"
  - "Include concrete examples (positive and negative)"
  - "Document anti-patterns with detection and fix"
  - "Update contract when reality changes (especially Complex domain)"
  - "Version contracts when breaking changes occur"
  - "Test implementation against contract before committing"
  - "Use progressive disclosure: load relevant context only"
  - "Follow project architecture conventions"

# --------------------------
# Validation rules
# --------------------------
validation_rules:
  format:
    - "Contract must parse as valid YAML 1.2"
    - "All required fields present for complexity level"
    - "All file references use relative paths from project root"
    - "No circular contract references"
    - "Project field matches project name"

  testability:
    - "Acceptance criteria are testable (automated or manual)"
    - "Invariants are declarative statements"
    - "Anti-patterns include detection method and fix"

  contextual_locality:
    - "No implicit knowledge assumptions (no 'directly', 'obviously', 'clearly')"
    - "All file references include full path and export name (@tokens/path/file#export)"
    - "All tool references include config file location and specific setting"
    - "Negative statements paired with positive alternative (NOT X, use Y instead)"
    - "Finite sets enumerated exhaustively (variants: a|b|c, not 'a, b, and others')"
    - "Format specifications include data type, range, validation rules, example"

  tokenomics:
    - "Contract focused on single deliverable (not multiple unrelated items)"
    - "External references used for non-critical details (examples, history)"
    - "Critical info inlined (preconditions, postconditions, invariants, acceptance)"
    - "Concise phrasing without ambiguity"

# --------------------------
# Final acceptance
# --------------------------
final_acceptance:
  - "Contract validates against meta-schema"
  - "All required fields present for complexity level"
  - "Acceptance criteria defined and testable"
  - "No anti-patterns present"
  - "Types are explicit and correct"
  - "Build succeeds with project build command"
  - "Human reviewer approval"

# --------------------------
# Integration with TaskLogs
# --------------------------
tasklogs_integration:
  purpose: "TaskLogs document WHAT was done, Contracts specify RULES and CONSTRAINTS"
  workflow:
    - "Before task: Write contract (if needed)"
    - "During task: Follow contract, update TaskLog with progress"
    - "After task: Verify contract compliance, append TaskLog entry"

  cross_reference:
    - "TaskLogs can reference contracts: 'Implemented per CONTRACT-BUTTON-001'"
    - "Contracts can reference TaskLogs: 'See TASK_button_implementation_20251016'"

# End of METACONTRACT.yml
